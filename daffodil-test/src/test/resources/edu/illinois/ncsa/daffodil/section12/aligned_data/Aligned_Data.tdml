<?xml version="1.0" encoding="UTF-8"?>
<tdml:testSuite xmlns:tdml="http://www.ibm.com/xmlns/dfdl/testData"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dfdl="http://www.ogf.org/dfdl/dfdl-1.0/"
  xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ex="http://example.com">


  <tdml:defineSchema name="s1">

    <dfdl:format ref="ex:daffodilTest1" />

    <xs:element name="e" type="xs:string" dfdl:lengthKind="delimited"
      dfdl:leadingSkip="3" />
    <xs:element name="e2" type="xs:string" dfdl:lengthKind="delimited"
      dfdl:leadingSkip="3000000" />

  </tdml:defineSchema>
  
  <tdml:defineSchema name="alignmentSchema">
    
    <dfdl:format ref="ex:daffodilTest1" representation="binary" encoding="utf-8" alignmentUnits="bits" alignment="4" leadingSkip="0"/>
    
    <xs:element name="string32be" dfdl:representation="text" type="xs:string" dfdl:encoding="utf-32be" dfdl:lengthKind="explicit" dfdl:length="4" dfdl:lengthUnits="bytes"
      dfdl:alignment="2" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0"/>


    <xs:simpleType name="uByte2Bits" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:length="2" dfdl:leadingSkip="4">
      <xs:restriction base="xs:unsignedByte"/>
    </xs:simpleType>

    <xs:element name="e" type="xs:unsignedByte" dfdl:lengthKind="implicit" dfdl:alignment="2" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4" />
    <xs:element name="e2" type="xs:unsignedInt" dfdl:lengthKind="implicit" dfdl:alignment="2" dfdl:alignmentUnits="bits" dfdl:leadingSkip="8" />
    <xs:element name="e3" dfdl:leadingSkip="0">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:uByte2Bits"/>
          <xs:element name="two" type="ex:uByte2Bits"/>
          <xs:element name="three" type="ex:uByte2Bits"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" dfdl:alignment="8" type="ex:uByte2Bits"/>
          <xs:element name="two" dfdl:alignment="8" type="ex:uByte2Bits"/>
          <xs:element name="three" dfdl:alignment="8" type="ex:uByte2Bits"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    

    <xs:simpleType name="explUIntBit" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0">
      <xs:restriction base="xs:unsignedInt"/>
    </xs:simpleType>
    <xs:simpleType name="explUIntByte" dfdl:lengthKind="explicit" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="0">
      <xs:restriction base="xs:unsignedInt"/>
    </xs:simpleType>
    <xs:simpleType name="explUIntMix" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="0">
      <xs:restriction base="xs:unsignedInt"/>
    </xs:simpleType>

    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:explUIntBit" dfdl:length="2" dfdl:alignment="4"/>
          <xs:element name="two" type="ex:explUIntBit" dfdl:length="6" dfdl:alignment="4"/>
          <xs:element name="three" type="ex:explUIntBit" dfdl:length="1" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e6">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:explUIntBit" dfdl:length="3" dfdl:alignment="4"/>
          <xs:element name="two" type="ex:explUIntBit" dfdl:length="9" dfdl:alignment="8"/>
          <xs:element name="three" type="ex:explUIntBit" dfdl:length="1" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e7">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:explUIntMix" dfdl:length="6" dfdl:alignment="1"/>
          <xs:element name="two" type="ex:explUIntMix" dfdl:length="3" dfdl:alignment="2"/>
          <xs:element name="three" type="ex:explUIntMix" dfdl:length="12" dfdl:alignment="1"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e8">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:explUIntByte" dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="two" type="ex:explUIntByte" dfdl:length="1" dfdl:alignment="2"/>
          <xs:element name="three" type="ex:explUIntByte" dfdl:length="3" dfdl:alignment="1"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e9">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="ex:explUIntByte" dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="two" type="ex:explUIntByte" dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="three" type="ex:explUIntByte" dfdl:length="3" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e10">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits"
            dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="two" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits"
            minOccurs="0" maxOccurs="1" dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="three" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits"
            dfdl:length="3" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e10a">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            minOccurs="0" maxOccurs="1" dfdl:lengthUnits="bits" dfdl:length="1" dfdl:alignment="1"/>
          <xs:element name="two" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            dfdl:length="1" dfdl:lengthUnits="bits" dfdl:alignment="2"/>
          <xs:element name="three" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            dfdl:length="3" dfdl:lengthUnits="bits" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e10b">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="varArr">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="e" type="xs:unsignedInt" dfdl:lengthKind="explicit" 
                  minOccurs="0" maxOccurs="5" dfdl:lengthUnits="bits" dfdl:length="8" dfdl:alignment="2"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="one" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            minOccurs="0" maxOccurs="1" dfdl:lengthUnits="bits" dfdl:length="8" dfdl:alignment="1"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e10c">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="one" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            minOccurs="0" maxOccurs="1" dfdl:lengthUnits="bits" dfdl:length="8" dfdl:alignment="1"/>
          <xs:element name="two" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            dfdl:length="8" dfdl:lengthUnits="bits" dfdl:alignment="2"/>
          <xs:element name="three" type="xs:unsignedInt" dfdl:lengthKind="explicit"
            dfdl:length="3" dfdl:lengthUnits="bits" dfdl:alignment="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e11" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="4" dfdl:encoding="utf-8" 
      dfdl:lengthUnits="bytes" dfdl:alignment="4" dfdl:leadingSkip="4">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:maxLength value="4" />
          <xs:minLength value="4" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>

    <xs:element name="e12">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="bits" type="xs:unsignedByte" dfdl:represenation="binary" dfdl:leadingSkip="0" dfdl:alignment="1" 
            dfdl:alignmentUnits="bits" dfdl:lengthKind="explicit" dfdl:lengthUnits="bits" dfdl:length="4"/>
          <xs:element name="string" type="xs:string" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="4" dfdl:encoding="utf-8" dfdl:leadingSkip="0"
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits">
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e13" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
      dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4"/>
    
    <xs:element name="e14" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
      dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>

    <xs:element name="e15">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e13" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4"/>
          <xs:element name="e14" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e16">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e14" type="xs:string" dfdl:terminator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="0" dfdl:trailingSkip="8"/>
          <xs:element name="e13" type="xs:string" dfdl:initiator=":" dfdl:representation="text" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:encoding="utf-8" 
            dfdl:lengthUnits="bytes" dfdl:alignment="8" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>
  
  <tdml:defineSchema name="implicitAlignmentSchema">

    <dfdl:format ref="ex:daffodilTest1" representation="binary" encoding="utf-8" 
      lengthUnits="bits" alignmentUnits="bits" binaryNumberRep="binary"/>

    <xs:element name="string" dfdl:lengthKind="implicit" dfdl:length="4" dfdl:encoding="utf-8" 
      dfdl:lengthUnits="bytes" dfdl:alignment="implicit" dfdl:leadingSkip="4">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:maxLength value="4" />
          <xs:minLength value="4" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>

    <xs:element name="hB" type="xs:hexBinary" dfdl:lengthKind="delimited" dfdl:alignment="implicit" dfdl:alignmentUnits="bits" dfdl:leadingSkip="4" />
    <xs:element name="hB2" type="xs:hexBinary" dfdl:lengthKind="delimited" dfdl:alignment="implicit" dfdl:alignmentUnits="bytes" dfdl:leadingSkip="4" />

    <xs:element name="uInt" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:length="32" dfdl:alignment="implicit" dfdl:leadingSkip="1"/>
    <xs:element name="uShort" type="xs:unsignedShort" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:alignment="implicit" dfdl:leadingSkip="1"/>
    <xs:element name="uLong" type="xs:unsignedLong" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="5"/>
    <xs:element name="int" type="xs:int" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="16"/>
    <xs:element name="short" type="xs:short" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="6"/>
    <xs:element name="long" type="xs:long" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="20"/>
    <xs:element name="byte" type="xs:byte" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="2"/>
    <xs:element name="uByte" type="xs:unsignedByte" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="2"/>
    <xs:element name="float" type="xs:float" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="2" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bytes"/>
    <xs:element name="double" type="xs:double" dfdl:lengthKind="implicit" dfdl:alignment="implicit" dfdl:leadingSkip="2" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bytes"/>
    
    <xs:element name="nonNeg" type="xs:nonNegativeInteger" dfdl:lengthKind="explicit" dfdl:length="5" dfdl:alignment="implicit" dfdl:leadingSkip="2" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bytes"/>
    <xs:element name="nonNeg2" type="xs:nonNegativeInteger" dfdl:lengthKind="explicit" dfdl:length="2" dfdl:alignment="implicit" dfdl:leadingSkip="1" dfdl:lengthUnits="bytes" dfdl:alignmentUnits="bits"/>
      
 <!-- TEXTUAL DATA -->
      
    <xs:element name="string2" type="xs:string" dfdl:lengthKind="explicit" dfdl:length="3" dfdl:lengthUnits="bytes" dfdl:alignment="implicit" dfdl:leadingSkip="16"
    dfdl:representation="text"/>
  
    <dfdl:defineFormat name="textImp">
      <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited" representation="text" alignment="implicit" alignmentUnits="bytes" />
    </dfdl:defineFormat>
    <dfdl:defineFormat name="textImpBitAlign">
      <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited" representation="text" alignment="implicit" alignmentUnits="bits" />
    </dfdl:defineFormat>
  
    <xs:element name="uIntT" type="xs:unsignedInt" dfdl:ref="ex:textImp" dfdl:leadingSkip="1"/>
    <xs:element name="uIntT2" type="xs:unsignedInt" dfdl:ref="ex:textImp" dfdl:encoding="utf-16be" dfdl:leadingSkip="1"/>
    <xs:element name="uShortT" type="xs:unsignedShort" dfdl:ref="ex:textImp" dfdl:leadingSkip="1"/>
    <xs:element name="uShortT2" type="xs:unsignedShort" dfdl:ref="ex:textImp" dfdl:encoding="utf-16be" dfdl:leadingSkip="1"/>
    <xs:element name="uLongT" type="xs:unsignedLong" dfdl:ref="ex:textImp" dfdl:leadingSkip="5"/>
    <xs:element name="longT" type="xs:long" dfdl:ref="ex:textImp" dfdl:leadingSkip="20"/>
    
    <xs:element name="dateT" type="xs:date" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="dd MM yyyy" dfdl:ref="ex:textImp" dfdl:leadingSkip="5"/>
    <xs:element name="dateT2" type="xs:date" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="EEEE 'in' MMMM - yyyy" dfdl:ref="ex:textImp" dfdl:leadingSkip="5"/>
    <xs:element name="timeT" type="xs:time" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ss" dfdl:ref="ex:textImp" dfdl:leadingSkip="5"/>
    <xs:element name="dateTimeT" type="xs:dateTime" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="EEEE MM yyyy - hh:mm:ss" dfdl:ref="ex:textImp" dfdl:leadingSkip="5"/>
    
    <xs:element name="intT" type="xs:int" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="2"/>
    <xs:element name="shortT" type="xs:short" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="6"/>
    <xs:element name="byteT" type="xs:byte" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="2"/>
    <xs:element name="byteT2" type="xs:byte" dfdl:ref="ex:textImpBitAlign" dfdl:encoding="utf-16le" dfdl:leadingSkip="2"/>
    <xs:element name="uByteT" type="xs:unsignedByte" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="2"/>
    <xs:element name="floatT" type="xs:float" dfdl:lengthUnits="bytes" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="2"/>
    <xs:element name="doubleT" type="xs:double" dfdl:ref="ex:textImpBitAlign" dfdl:leadingSkip="2"/>

  </tdml:defineSchema>
  
  <!--
     Test Name: impAlignmentHexBinary
        Schema: implicitAlignmentSchema
          Root: hB
          Purpose: This test demonstrates that the implicit alignment for hexBinary data is 8 bits
  -->
  
  <tdml:parserTestCase name="impAlignmentHexBinary" root="hB"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - hexBinary - DFDL-12-029R">

    <tdml:document>
      <tdml:documentPart type="bits">0101</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">1101</tdml:documentPart> <!-- padding to fulfill alignment -->
      <tdml:documentPart type="bits">11110100</tdml:documentPart> <!-- hB -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <hB>F4</hB>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: impAlignmentHexBinary2
        Schema: implicitAlignmentSchema
          Root: hB2
          Purpose: This test demonstrates that the implicit alignment for hexBinary data is 1 byte
  -->
  
  <tdml:parserTestCase name="impAlignmentHexBinary2" root="hB2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - hexBinary - DFDL-12-029R">

    <tdml:document>
      <tdml:documentPart type="byte">ab 43 82 b3</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">ba ba 00 00</tdml:documentPart> <!-- hB -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <hB2>BABA0000</hB2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignment01
        Schema: alignmentSchema
          Root: e
       Purpose: This test demonstrates that alignment (2 bits) is applied after leadingSkip (4 bits)
  -->
  
  <tdml:parserTestCase name="alignment01" root="e"
    model="alignmentSchema" description="Section 12.1 Aligned Data - DFDL-12-002R">

    <tdml:document>
      <tdml:documentPart type="bits">0010 00000100</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>4</e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: alignment02
        Schema: alignmentSchema
          Root: e3
       Purpose: This test demonstrates that leadingSkip (4 bits) is applied before alignment (4 bits) on each element
  -->
  
  <tdml:parserTestCase name="alignment02" root="e3"
    model="alignmentSchema" description="Section 12.1 Aligned Data - DFDL-12-002R">

    <tdml:document>
      <tdml:documentPart type="bits">00 00</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">11 10</tdml:documentPart> <!-- "one" and padding to fulfill alignment-->
      <tdml:documentPart type="bits">10 01</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">10 11</tdml:documentPart> <!-- "two" and padding to fulfill alignment -->
      <tdml:documentPart type="bits">01 10</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">00</tdml:documentPart> <!-- "three" -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e3>
          <one>3</one>
          <two>2</two>
          <three>0</three>
        </e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignment03
        Schema: alignmentSchema
          Root: e4
       Purpose: This test demonstrates that the leadingSkip (4 bits) is applied before alignment (4 bits)
                for the first element.
  -->
  
  <tdml:parserTestCase name="alignment03" root="e4"
    model="alignmentSchema" description="Section 12.1 Aligned Data - DFDL-12-002R">

    <tdml:document>
      <tdml:documentPart type="bits">00 00</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">11 10</tdml:documentPart> 
      <tdml:documentPart type="bits">01</tdml:documentPart> <!-- "one" starting at bit position 8 -->
      <tdml:documentPart type="bits">00 10 01</tdml:documentPart>
      <tdml:documentPart type="bits">10</tdml:documentPart> <!-- "two" starting at bit position 16 -->
      <tdml:documentPart type="bits">11 00 00</tdml:documentPart>
      <tdml:documentPart type="bits">11</tdml:documentPart> <!-- "three" starting at bit position 24 -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e4>
          <one>1</one>
          <two>2</two>
          <three>3</three>
        </e4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: leadingSkip1
        Schema: s1
          Root: e
       Purpose: This test demonstrates a leadingSkip of 3 bytes. The actual data begins at the 4th byte.
  -->

  <tdml:parserTestCase name="leadingSkip1" root="e"
    model="s1" description="Section 12.1 Aligned Data - DFDL-12-005R">

    <tdml:document>
      <tdml:documentPart type="byte">aabbcc</tdml:documentPart>
      <tdml:documentPart type="text">Hello</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>Hello</e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: leadingSkip2
        Schema: s1
          Root: e2
       Purpose: This test demonstrates that there is a limit to the size of a leadingSkip (1024).
  -->

  <tdml:parserTestCase name="leadingSkip2" root="e2"
    model="s1" description="Section 12.1 Aligned Data - DFDL-12-005R">

    <tdml:document />

    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Property leadingSkip 3000000 is larger than limit 1024</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentString1
        Schema: implicitAlignmentSchema
          Root: string
       Purpose: This test demonstrates that the implicit alignment for an xs:string (binary)
                is not allowed
   -->

  <tdml:parserTestCase name="implicitAlignmentString1" root="string"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - String - DFDL-12-014R">

    <tdml:document>
      <tdml:documentPart type="bits">0110 0111</tdml:documentPart> <!-- leadingSkip and buffer to fulfill alignment -->
      <tdml:documentPart type="bits">01101111 01100001 01110100 01110011</tdml:documentPart> <!-- string -->
    </tdml:document>

    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Implicit Alignment is not allowed for String with representation='binary'</tdml:error>
      <tdml:error>Use representation='text' instead.</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>


  <!--
     Test Name: implicitAlignmentString2
        Schema: implicitAlignmentSchema
          Root: string2
       Purpose: This test demonstrates that the implicit alignment for the text representation of type 'string' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentString2" root="string2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - String - DFDL-12-014R">

    <tdml:document>
      <tdml:documentPart type="bits">01100111 01101111</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">01100001 01110100 01110011</tdml:documentPart> <!-- string -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <string2>ats</string2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUInt1
        Schema: implicitAlignmentSchema
          Root: uInt
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedInt' is 32 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUInt" root="uInt"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedInt (binary) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="bits">1 0000000 00000000 00000000 00000000</tdml:documentPart> <!-- leadingSkip and buffer to fulfill alignment -->
      <tdml:documentPart type="bits">00000000 00000000 00000000 00001101</tdml:documentPart> <!-- uInt -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uInt>13</uInt>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUInt1b
        Schema: implicitAlignmentSchema
          Root: uIntb
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedInt' is 32 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUIntb" root="uIntb"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedInt (binary) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="bits">1 0000000 00000000 00000000 00000000</tdml:documentPart> <!-- leadingSkip and buffer to fulfill alignment -->
      <tdml:documentPart type="bits">00000000 00000000 00000000 00001101</tdml:documentPart> <!-- uInt -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uIntb>13</uIntb>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUShort
        Schema: implicitAlignmentSchema
          Root: uShort
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedShort' is 16 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUShort" root="uShort"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedShort (binary) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="bits">1 0000000 00000000</tdml:documentPart> <!-- leadingSkip and buffer to fulfill alignment -->
      <tdml:documentPart type="bits">01101</tdml:documentPart> <!-- uShort -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uShort>13</uShort>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUShortb
        Schema: implicitAlignmentSchema
          Root: uShortb
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedShort' is 16 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUShortb" root="uShortb"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedShort (binary) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="bits">1 0000000 00000000</tdml:documentPart> <!-- leadingSkip and buffer to fulfill alignment -->
      <tdml:documentPart type="bits">01101</tdml:documentPart> <!-- uShort -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uShortb>13</uShortb>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentInt
        Schema: implicitAlignmentSchema
          Root: int
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'int' is 32 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentInt" root="int"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - int (binary) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="byte">a4 b4</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">a9 cc</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="byte">00 00 00 1d</tdml:documentPart> <!-- int -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <int>29</int>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentInt2
        Schema: implicitAlignmentSchema
          Root: int
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'int' is 32 bits
                This test uses the binary representation of a negative number. 
  -->

  <tdml:parserTestCase name="implicitAlignmentInt2" root="int"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - int (binary) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="byte">a4 b4</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">a9 cc</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="byte">ff ff ff e3</tdml:documentPart> <!-- int -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <int>-29</int>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentShort
        Schema: implicitAlignmentSchema
          Root: short
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'short' is 16 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentShort" root="short"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - short (binary) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="bits">100100</tdml:documentPart> <!-- leadingSkip (6 bits) -->
      <tdml:documentPart type="bits">11011000 10</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">00000000 10010101</tdml:documentPart> <!-- short -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <short>149</short>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentShort2
        Schema: implicitAlignmentSchema
          Root: short
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'short' is 16 bits
                The data is the binary representation of a negative value.   
  -->

  <tdml:parserTestCase name="implicitAlignmentShort2" root="short"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - short (binary) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="bits">100100</tdml:documentPart> <!-- leadingSkip (6 bits) -->
      <tdml:documentPart type="bits">11011000 10</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">11111111 01101011</tdml:documentPart> <!-- short -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <short>-149</short>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentLong
        Schema: implicitAlignmentSchema
          Root: long
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'long' is 64 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentLong" root="long"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - long (binary) - DFDL-12-018R">

    <tdml:document>
      <tdml:documentPart type="bits">11010101 10101010 1101</tdml:documentPart> <!-- leadingSkip (20 bits) -->
      <tdml:documentPart type="bits">1101 01000101 11010010 11010010 11001000 00000010</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="byte">00 b3 b3 b3 b3 b3 b3 b3</tdml:documentPart> <!-- long -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <long>50581605226623923</long>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentByte
        Schema: implicitAlignmentSchema
          Root: byte
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'byte' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentByte" root="byte"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - byte (binary) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">11</tdml:documentPart> <!-- leadingSkip (2 bits) -->
      <tdml:documentPart type="bits">110101</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">01001010</tdml:documentPart> <!-- byte -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byte>74</byte>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentByte2
        Schema: implicitAlignmentSchema
          Root: byte
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'byte' is 8 bits
                The data provided represents a negative value.   
  -->

  <tdml:parserTestCase name="implicitAlignmentByte2" root="byte"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - byte (binary) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">11</tdml:documentPart> <!-- leadingSkip (2 bits) -->
      <tdml:documentPart type="bits">110101</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">10110110</tdml:documentPart> <!-- byte -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byte>-74</byte>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUByte
        Schema: implicitAlignmentSchema
          Root: uByte
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedByte' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUByte" root="uByte"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedByte (binary) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">11</tdml:documentPart> <!-- leadingSkip (2 bits) -->
      <tdml:documentPart type="bits">110101</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">01001010</tdml:documentPart> <!-- uByte -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uByte>74</uByte>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUByte2
        Schema: implicitAlignmentSchema
          Root: uByte
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'unsignedByte' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentUByte2" root="uByte"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedByte (binary) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">11</tdml:documentPart> <!-- leadingSkip (2 bits) -->
      <tdml:documentPart type="bits">110101</tdml:documentPart> <!-- buffer to fulfill alignment -->
      <tdml:documentPart type="bits">10110110</tdml:documentPart> <!-- uByte -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uByte>182</uByte>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUIntT
        Schema: implicitAlignmentSchema
          Root: uIntT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedInt' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentUIntT" root="uIntT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedInt (text) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="text">3</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="text">42</tdml:documentPart> <!-- uIntT -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uIntT>42</uIntT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUIntT2
        Schema: implicitAlignmentSchema
          Root: uIntT2
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedInt' is
       encoding-specific (generally 8 bits, even though encoding is utf-16be). In this case the data isn't accounting for 
       the leadingSkip, so the test will fail with a useful error message.
  -->

  <tdml:parserTestCase name="implicitAlignmentUIntT2" root="uIntT2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedInt (text) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="byte">00 34 00 32</tdml:documentPart> <!-- uIntT - byte-representation of the number 42 -->
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Convert to Unsigned Int (for xs:unsignedInt)</tdml:error>
      <tdml:error>Unable to parse '㐀' (using up all characters).</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  
  <!--
     Test Name: implicitAlignmentUIntT2b
        Schema: implicitAlignmentSchema
          Root: uIntT2
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedInt' is
                encoding-specific (generally 8 bits - in this case it should be 8 bits even though the encoding is utf-16be)
  -->

  <tdml:parserTestCase name="implicitAlignmentUIntT2b" root="uIntT2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedInt (text) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="byte">00</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">00 34 00 32</tdml:documentPart> <!-- uIntT - byte-representation of the number 42 -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uIntT2>42</uIntT2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUShortT2b
        Schema: implicitAlignmentSchema
          Root: uShortT2
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedShort' is
                encoding-specific (generally 8 bits - in this case it should be 8 bits even though the encoding is utf-16be)
  -->

  <tdml:parserTestCase name="implicitAlignmentUShortT2b" root="uShortT2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedShort (text) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="byte">00</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">00 32</tdml:documentPart> <!-- uIntT - byte-representation of the number 2 -->
    </tdml:document>
    
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uShortT2>2</uShortT2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentULongT
        Schema: implicitAlignmentSchema
          Root: uLongT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedLong' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentULongT" root="uLongT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedLong (text) - DFDL-12-018R">

    <tdml:document>
      <tdml:documentPart type="byte">32 32 32 32 32</tdml:documentPart> <!-- leadingSkip plus 3 filler bits for alignment (8 bits) -->
      <tdml:documentPart type="byte">31 32 33 34 35 36 37 38</tdml:documentPart> <!-- uLongT - byte-representation of 12345678  -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uLongT>12345678</uLongT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentULongT2
        Schema: implicitAlignmentSchema
          Root: uLongT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedLong' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentULongT2" root="uLongT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedLong (text) - DFDL-12-018R">

    <tdml:document>
      <tdml:documentPart type="bits">10101111 10001010</tdml:documentPart> <!-- 2 bytes of leadingSkip (in bits) -->
      <tdml:documentPart type="byte">31 32 33</tdml:documentPart> <!-- remaining 3 bytes of leadingSkip (in bytes) -->
      <tdml:documentPart type="byte">31 32 33 34 35 36 37 38</tdml:documentPart> <!-- uLongT - byte-representation of 12345678  -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uLongT>12345678</uLongT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentIntT
        Schema: implicitAlignmentSchema
          Root: intT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'int' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentIntT" root="intT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - int (text) - DFDL-12-019R">

    <tdml:document>
      <tdml:documentPart type="bits">01 101001</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">31 32 33 34</tdml:documentPart> <!-- intT - byte-representation of 1234  -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <intT>1234</intT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentShortT
        Schema: implicitAlignmentSchema
          Root: shortT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'short' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentShortT" root="shortT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - short (text) - DFDL-12-020R">

    <tdml:document>
      <tdml:documentPart type="bits">011010 01</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">31 32</tdml:documentPart> <!-- shortT - byte-representation of 12  -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <shortT>12</shortT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentByteT
        Schema: implicitAlignmentSchema
          Root: byteT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'byte' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentByteT" root="byteT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - byte (text) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">01 111111</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">2D 31</tdml:documentPart> <!-- byteT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byteT>-1</byteT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: implicitAlignmentByteT2
        Schema: implicitAlignmentSchema
          Root: byteT2
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'byte' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentByteT2" root="byteT2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - byte (text) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">10 111111</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">2D 00 31 00</tdml:documentPart> <!-- byteT2 -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byteT2>-1</byteT2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUByteT
        Schema: implicitAlignmentSchema
          Root: uByteT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedByte' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentUByteT" root="uByteT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedByte (text) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">10 111111</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">2D 31</tdml:documentPart> <!-- uByteT -->
    </tdml:document>

    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Convert to Unsigned Byte</tdml:error>
      <tdml:error>Out of Range: '-1' converted to -1</tdml:error>
      <tdml:error>not in range for the type</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentUByteT2
        Schema: implicitAlignmentSchema
          Root: uByteT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'unsignedByte' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentUByteT2" root="uByteT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - unsignedByte (text) - DFDL-12-021R">

    <tdml:document>
      <tdml:documentPart type="bits">10 111111</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">31</tdml:documentPart> <!-- uByteT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uByteT>1</uByteT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentDateT
        Schema: implicitAlignmentSchema
          Root: dateT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'date' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentDateT" root="dateT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - date (text) - DFDL-12-024R">

    <tdml:document>
      <tdml:documentPart type="text">junk!31 03 2013</tdml:documentPart> <!-- leadingSkip (junk!) and dateT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateT>2013-03-31+00:00</dateT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentDateT2
        Schema: implicitAlignmentSchema
          Root: dateT2
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'date' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentDateT2" root="dateT2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - date (text) - DFDL-12-024R">

    <tdml:document>
      <tdml:documentPart type="text">Bleak Monday in May - 2013</tdml:documentPart> <!-- leadingSkip (Bleak) and dateT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateT2>2013-05-06+00:00</dateT2>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentTimeT
        Schema: implicitAlignmentSchema
          Root: timeT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'time' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentTimeT" root="timeT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - time (text) - DFDL-12-026R">

    <tdml:document>
      <tdml:documentPart type="text">time: 04:09:23</tdml:documentPart> <!-- leadingSkip (time:) and timeT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <timeT>04:09:23.000000+00:00</timeT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentDateTimeT
        Schema: implicitAlignmentSchema
          Root: dateTimeT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'dateTime' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentDateTimeT" root="dateTimeT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - dateTime (text) - DFDL-12-022R">

    <tdml:document>
      <tdml:documentPart type="text">look: Friday 05 2013 - 03:30:30</tdml:documentPart> <!-- leadingSkip (look:) and dateTimeT -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTimeT>2013-05-03T03:30:30.000000+00:00</dateTimeT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentFloatT
        Schema: implicitAlignmentSchema
          Root: floatT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'float' is
                encoding-specific (generally 8 bits)
  -->

  <tdml:parserTestCase name="implicitAlignmentFloatT" root="floatT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - float (text) - DFDL-12-015R">

    <tdml:document>
      <tdml:documentPart type="text">3</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="text">42.2</tdml:documentPart> <!-- float -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <floatT>42.2</floatT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentFloat
        Schema: implicitAlignmentSchema
          Root: float
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'float' is 32 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentFloat" root="float"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - float (binary) - DFDL-12-015R">

    <tdml:document>
      <tdml:documentPart type="byte">2A 00 90 0D</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">42 28 CC CD</tdml:documentPart> <!-- float -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <float>42.2</float>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentDouble
        Schema: implicitAlignmentSchema
          Root: double
       Purpose: This test demonstrates that the implicit alignment for the binary representation of type 'double' is 64 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentDouble" root="double"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - double (binary) - DFDL-12-016R">

    <tdml:document>
      <tdml:documentPart type="byte">2A 00 90 0D 2A 45 9F 9E</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">42 28 CC CD AB B7 78 09</tdml:documentPart> <!-- double -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double>5.325762300373444E10</double>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: implicitAlignmentDoubleT
        Schema: implicitAlignmentSchema
          Root: doubleT
       Purpose: This test demonstrates that the implicit alignment for the textual representation of type 'double' is 8 bits
  -->

  <tdml:parserTestCase name="implicitAlignmentDoubleT" root="doubleT"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - double (text) - DFDL-12-016R">

    <tdml:document>
      <tdml:documentPart type="byte">2A</tdml:documentPart> <!-- leadingSkip and padding for alignment -->
      <tdml:documentPart type="byte">35 2E 33 32 35 37 36 32 33 30 30 33 37 33 34 34 34 45 31 30</tdml:documentPart> <!-- double -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <doubleT>5.325762300373444E10</doubleT>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: explicitAlignmentNoSkips01
        Schema: alignmentSchema
          Root: e5
       Purpose: This test demonstrates that the length of the alignment fill region is the smallest non-negative
                integer L such that (L+N) mod B(4) = 1. The position of the first bit of the aligned element is P = L + N   
  -->

  <tdml:parserTestCase name="explicitAlignmentNoSkips01" root="e5"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - alignmentUnits - DFDL-12-010R">

    <tdml:document>
      <tdml:documentPart type="bits">01 00 100101 00 1</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e5>
          <one>1</one>
          <two>37</two>
          <three>1</three>
        </e5>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: explicitAlignmentNoSkips02
        Schema: alignmentSchema
          Root: e6
       Purpose: This test demonstrates that the length of the alignment fill region is the smallest non-negative
                integer L such that (L+N) mod B(4) = 1. The position of the first bit of the aligned element is P = L + N   
  -->

  <tdml:parserTestCase name="explicitAlignmentNoSkips02" root="e6"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - alignmentUnits - DFDL-12-010R">

    <tdml:document>
      <tdml:documentPart type="bits">011 00000 010011000 001 0</tdml:documentPart>
      <!--                           |         |             |                 -->
      <!--                           one       two           three             -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e6>
          <one>3</one>
          <two>152</two>
          <three>0</three>
        </e6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  
  </tdml:parserTestCase>
    
  <!--
     Test Name: explicitAlignmentNoSkips03
        Schema: alignmentSchema
          Root: e7
       Purpose: This test demonstrates that the length of the alignment fill region is the smallest non-negative
                integer L such that (L+N) mod B(4) = 1. The position of the first bit of the aligned element is P = L + N   
  -->

  <tdml:parserTestCase name="explicitAlignmentNoSkips03" root="e7"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - alignmentUnits - DFDL-12-010R">

    <tdml:document>
      <tdml:documentPart type="bits">011100 0001001100 000 10100 000100001111</tdml:documentPart>
      <!--                           |                 |         |                 -->
      <!--                           one               two       three             -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e7>
          <one>28</one>
          <two>0</two>
          <three>271</three>
        </e7>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: explicitAlignmentNoSkips04
        Schema: alignmentSchema
          Root: e8
       Purpose: This test demonstrates that the length of the alignment fill region is the smallest non-negative
                integer L such that (L+N) mod B(4) = 1. The position of the first bit of the aligned element is P = L + N   
  -->

  <tdml:parserTestCase name="explicitAlignmentNoSkips04" root="e8"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - alignmentUnits - DFDL-12-010R">

    <tdml:document>
      <tdml:documentPart type="bits">00000001 11111111 00001100 00010100 00000000 00000000</tdml:documentPart>
      <!--                           |                 |        |                                          -->
      <!--                           one               two      three                                      -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e8>
          <one>1</one>
          <two>12</two>
          <three>1310720</three>
        </e8>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: explicitAlignmentNoSkips05
        Schema: alignmentSchema
          Root: e9
       Purpose: This test demonstrates that the length of the alignment fill region is the smallest non-negative
                integer L such that (L+N) mod B(4) = 1. The position of the first bit of the aligned element is P = L + N   
  -->

  <tdml:parserTestCase name="explicitAlignmentNoSkips05" root="e9"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - alignmentUnits - DFDL-12-010R">

    <tdml:document>
      <tdml:documentPart type="bits">00000001 00001100 00010100 00000000 10000000 00000000 00000001</tdml:documentPart>
      <!--                           |        |                          |                             -->
      <!--                           one      two                        three                         -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e9>
          <one>1</one>
          <two>12</two>
          <three>8388609</three>
        </e9>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentOptionalElem
        Schema: alignmentSchema
          Root: e10
       Purpose: This test demonstrates that optional elements cannot have alignment properties different from the items
                that follow them, or a SDE will be thrown.
  -->

  <tdml:parserTestCase name="alignmentOptionalElem" root="e10"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Avoid Ambiguity when parsing - DFDL-12-011R">

    <tdml:document>
      <tdml:documentPart type="bits">1 0 101</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentOptionalElem02
        Schema: alignmentSchema
          Root: e10a
       Purpose: This test demonstrates that optional elements cannot have alignment properties different from the items
                that follow them, or a SDE will be thrown.
  -->

  <tdml:parserTestCase name="alignmentOptionalElem02" root="e10a"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Avoid Ambiguity when parsing - DFDL-12-011R">

    <tdml:document>
      <tdml:documentPart type="bits">0 1 101</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentOptionalElem03
        Schema: alignmentSchema
          Root: e10b
       Purpose: This test demonstrates that optional elements cannot have alignment properties different from the items
                that follow them, or a SDE will be thrown.
  -->

  <tdml:parserTestCase name="alignmentOptionalElem03" root="e10b"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Avoid Ambiguity when parsing - DFDL-12-011R">

    <tdml:document>
      <tdml:documentPart type="bits">10101011 00100100 11111110 01001001</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentOptionalElem04
        Schema: alignmentSchema
          Root: e10c
       Purpose: This test demonstrates that optional elements cannot have alignment properties different from the items
                that follow them, or a SDE will be thrown.
  -->

  <tdml:parserTestCase name="alignmentOptionalElem04" root="e10c"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Avoid Ambiguity when parsing - DFDL-12-011R">

    <tdml:document>
      <tdml:documentPart type="bits">01000001 00001000 101</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentStringErr
        Schema: alignmentSchema
          Root: e11
       Purpose: This test demonstrates that a textual representation of a string has a mandatory alignment (generally 8 bits)
  -->

  <tdml:parserTestCase name="alignmentStringErr" root="e11"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Textual data - Mandatory Alignment - DFDL-12-025R">

    <tdml:document>
      <tdml:documentPart type="text">nope</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>The given alignment (4 bits) must be a multiple of the encoding specified alignment (8 bits) for String</tdml:error>
      <tdml:error>representation='text'</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentStringBitSkip
        Schema: alignmentSchema
          Root: e12
       Purpose: This test demonstrates that if the data is not aligned to the proper boundary for the encoding from textual 
                data is processed, bits are skipped.
  -->

  <tdml:parserTestCase name="alignmentStringBitSkip" root="e12"
    model="alignmentSchema" description="Section 12.1 Aligned Data - Textual data - Mandatory Alignment - DFDL-12-025R">

    <tdml:document>
      <tdml:documentPart type="bits">101 00000</tdml:documentPart>
      <tdml:documentPart type="text">nope</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e12>
          <bits>10</bits>
          <string>nope</string>
        </e12>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftFraming01
        Schema: alignmentSchema
          Root: e13
       Purpose: This test demonstrates that LeftFraming consists of a LeadingSkip, AlignmentFill, and an Initiator 
  -->

  <tdml:parserTestCase name="leftFraming01" root="e13"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">a</tdml:documentPart>
      <tdml:documentPart type="text">:strng</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e13>strng</e13>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: rightFraming01
        Schema: alignmentSchema
          Root: e14
       Purpose: This test demonstrates that RightFraming consists of a Terminator and TrailingSkip 
  -->

  <tdml:parserTestCase name="rightFraming01" root="e14"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">strng:a</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e14>strng</e14>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFraming01
        Schema: alignmentSchema
          Root: e15
       Purpose: This test demonstrates Right and Left Framing 
  -->

  <tdml:parserTestCase name="leftAndRightFraming01" root="e15"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">a:strnggnrts:a</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e15>
          <e13>strng</e13>
          <e14>gnrts</e14>
        </e15>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: leftAndRightFraming02
        Schema: alignmentSchema
          Root: e16
       Purpose: This test demonstrates Right and Left Framing 
  -->

  <tdml:parserTestCase name="leftAndRightFraming02" root="e16"
    model="alignmentSchema" description="Section 9 Framing - Aligned Data - DFDL-09-016R">

    <tdml:document>
      <tdml:documentPart type="text">gnrts:aa:strng</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e16>
          <e14>gnrts</e14>
          <e13>strng</e13>
        </e16>
      </tdml:dfdlInfoset>
    </tdml:infoset>
      
  </tdml:parserTestCase>
  
  <!--
     Test Name: encodingAlignmentUtf32be
        Schema: alignmentSchema
          Root: string32be
       Purpose: This test demonstrates that the alignment for Utf-32be encoded text must be 8-bit aligned
  -->

  <tdml:parserTestCase name="encodingAlignmentUtf32be" root="string32be"
    model="alignmentSchema" description="Section 12 - Aligned Data - DFDL-12-027R">

    <tdml:document>
      <tdml:documentPart type="byte">00 00 00 74 00 00 00 65 00 00 00 73 00 00 00 74</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>The given alignment (2 bits) must be a multiple of the encoding specified alignment (8 bits) for String when representation='text'</tdml:error>
      <tdml:error>Encoding: UTF-32BE</tdml:error>
    </tdml:errors> 
  </tdml:parserTestCase>
  
  <!--
     Test Name: alignmentUnitsInvalid
        Schema: InvalidAlignSchema.dfdl.xsd
          Root: e_invalid
       Purpose: This test demonstrates that DFDL properly handles a case where alignmentUnits is invalid
  -->

  <tdml:parserTestCase name="alignmentUnitsInvalid" root="e_invalid"
    model="InvalidAlignSchema.dfdl.xsd" description="Section 12 - Aligned Data - alignmentUnits - DFDL-12-003R">

    <tdml:document>
      <tdml:documentPart type="byte">12345</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value 'characters' is not facet-valid with respect to enumeration '[bits, bytes]'</tdml:error>
      <tdml:error>It must be a value from the enumeration</tdml:error>
    </tdml:errors> 
  </tdml:parserTestCase>
  
  <!--
     Test Name: impAlignmentNonNegativeInteger
        Schema: implicitAlignmentSchema
          Root: nonNeg
          Purpose: This test demonstrates that the implicit alignment for nonNegativeIntegers is 8 bits
  -->
  
  <tdml:parserTestCase name="impAlignmentNonNegativeInteger" root="nonNeg"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - nonNegativeInteger - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">01110101 11010010</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">00000000 00000000 00000000 00000010 00000001</tdml:documentPart> <!-- nonNeg -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNeg>513</nonNeg>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: impAlignmentNonNegativeInteger2
        Schema: implicitAlignmentSchema
          Root: nonNeg
          Purpose: This test demonstrates that the implicit alignment for nonNegativeIntegers is 1 byte
  -->
  
  <tdml:parserTestCase name="impAlignmentNonNegativeInteger2" root="nonNeg"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - nonNegativeInteger - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="byte">01 01</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="byte">00 00 00 02 01</tdml:documentPart> <!-- nonNeg -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNeg>513</nonNeg>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: impAlignmentNonNegativeInteger3
        Schema: implicitAlignmentSchema
          Root: nonNeg2
          Purpose: This test demonstrates that the implicit alignment for nonNegativeIntegers is 8 bits
  -->
  
  <tdml:parserTestCase name="impAlignmentNonNegativeInteger3" root="nonNeg2"
    model="implicitAlignmentSchema" description="Section 12.1 Aligned Data - Implicit Alignment - nonNegativeInteger - DFDL-12-017R">

    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart> <!-- leadingSkip -->
      <tdml:documentPart type="bits">1001010</tdml:documentPart> <!-- padding to fulfill alignment -->
      <tdml:documentPart type="bits">00000000 10001001</tdml:documentPart> <!-- nonNeg -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNeg2>137</nonNeg2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

</tdml:testSuite>
