<?xml version="1.0" encoding="UTF-8"?>
<tdml:testSuite suiteName="SimpleTypes" description="Section 5 - simple types"
	xmlns:tdml="http://www.ibm.com/xmlns/dfdl/testData" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:dfdl="http://www.ogf.org/dfdl/dfdl-1.0/" xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:ex="http://example.com">

	<tdml:defineSchema name="Functions.dfdl.xsd">
		<dfdl:format ref="ex:daffodilTest1" initiator=""
			separator="," terminator="" leadingSkip="0" trailingSkip="0"
			textBidi="no" floating="no" encoding="utf-8" byteOrder="bigEndian"
			alignment="1" alignmentUnits="bytes" fillByte="f" occursCountKind="implicit"
			truncateSpecifiedLengthString="no" ignoreCase="no" representation="text"
			lengthKind="delimited" nilValueDelimiterPolicy="both"
			emptyValueDelimiterPolicy="none" documentFinalTerminatorCanBeMissing="yes"
			initiatedContent="no" separatorSuppressionPolicy="never" separatorPosition="infix" />

		<xs:element name="testBit">
			<xs:complexType>
				<xs:sequence>
					<xs:element name="byte" type="xs:byte"
						dfdl:representation="binary" dfdl:lengthKind="implicit" />
					<xs:element name="bit0" type="xs:boolean"
						dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:byte/text(), 0) }" />
					<xs:element name="bit7" type="xs:boolean"
						dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:byte/text(), 7) }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>
		
    <xs:element name="testBit1">
			<xs:complexType>
				<xs:sequence>
					<xs:element name="byte" type="xs:byte"
						dfdl:representation="binary" dfdl:lengthKind="implicit" />
					<xs:element name="bit1" type="xs:boolean"
						dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:byte/text(), 1) }" />
					<xs:element name="bit2" type="xs:boolean"
						dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:byte/text(), 2) }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>
    
    <xs:element name="testBit2">
			<xs:complexType>
				<xs:sequence>
					<xs:element name="int" type="xs:unsignedInt" dfdl:representation="binary" dfdl:lengthKind="implicit" />
					<xs:element name="bit1" type="xs:boolean"
						dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:int/text(), 1) }" />
					<xs:element name="bit2" type="xs:boolean"
						dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:testBit( ../ex:int/text(), 2) }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>

		<xs:element name="setBits">
			<xs:complexType>
				<xs:sequence>
					<xs:element name="e" type="xs:byte" dfdl:lengthKind="implicit"
						dfdl:representation="binary" />
					<xs:element name="e0" type="xs:unsignedByte" dfdl:lengthKind="implicit"
						dfdl:inputValueCalc="{ dfdl:setBits(1, 0, 0, 0, 0, 0 , 0, 0) }" />
					<xs:element name="e1" type="xs:unsignedByte" dfdl:lengthKind="implicit"
						dfdl:inputValueCalc="{ dfdl:setBits(0, 1, 0, 0, 0, 0 , 0, 0) }" />
					<xs:element name="e2" type="xs:unsignedByte" dfdl:lengthKind="implicit"
						dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 1, 0, 0, 0 , 0, 0) }" />
					<xs:element name="e3" type="xs:unsignedByte" dfdl:lengthKind="implicit"
						dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 0, 1, 0, 0 , 0, 0) }" />
					<xs:element name="e4" type="xs:unsignedByte" dfdl:lengthKind="implicit"
						dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 0, 0, 1, 0 , 0, 0) }" />
					<xs:element name="e5" type="xs:unsignedByte" dfdl:lengthKind="implicit"
						dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 0, 0, 0, 1 , 0, 0) }" />
					<xs:element name="e6" type="xs:unsignedByte" dfdl:lengthKind="implicit"
						dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 0, 0, 0, 0 , 1, 0) }" />
					<xs:element name="e7" type="xs:unsignedByte" dfdl:lengthKind="implicit"
						dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 0, 0, 0, 0 , 0, 1) }" />
					<xs:element name="e8" type="xs:unsignedByte" dfdl:lengthKind="implicit"
						dfdl:inputValueCalc="{ dfdl:setBits(1, 1, 1, 1, 1, 1 , 1, 1) }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>
		
    <xs:element name="setBits1" type="xs:byte" dfdl:lengthKind="implicit"
						dfdl:inputValueCalc="{ dfdl:setBits(0, 0, 1, 0 , 0, 0) }" />
		
    <xs:element name="setBits2">
			<xs:complexType>
				<xs:sequence dfdl:separator=",">
					<xs:element name="e0" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
					<xs:element name="e1" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
					<xs:element name="e2" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
					<xs:element name="e3" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
					<xs:element name="e4" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
					<xs:element name="e5" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
					<xs:element name="e6" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
					<xs:element name="e7" type="xs:int" dfdl:lengthKind="explicit" dfdl:length="1" dfdl:representation="text" />
					<xs:element name="e" type="xs:byte" dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:setBits(/ex:setBits2/ex:e7, /ex:setBits2/ex:e6, /ex:setBits2/ex:e5, /ex:setBits2/ex:e4, /ex:setBits2/ex:e3, /ex:setBits2/ex:e2, /ex:setBits2/ex:e1, /ex:setBits2/ex:e0) }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>

		<xs:element name="occursCount">
			<xs:annotation>
				<xs:appinfo source="http://www.ogf.org/dfdl/">
					<dfdl:assert test="{ dfdl:occursCount( /ex:occursCount/* ) eq 3 }"
						message="Assertion 
            failed for dfdl:occursCount( /ex:occursCount/* ) eq 3" />
				</xs:appinfo>
			</xs:annotation>
			<xs:complexType>
				<xs:sequence>
					<xs:element name="i1" type="xs:int" />
					<xs:element name="i2" type="xs:int" />
					<xs:element name="i3" type="xs:int" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>
    
    <xs:element name="occursCount1">
			<xs:annotation>
				<xs:appinfo source="http://www.ogf.org/dfdl/">
					<dfdl:assert test="{ dfdl:occursCount( /ex:occursCount1/* ) eq 3 }"
						message="Assertion 
            failed for dfdl:occursCount( /ex:occursCount/* ) eq 3" />
				</xs:appinfo>
			</xs:annotation>
			<xs:complexType>
				<xs:sequence dfdl:separator=",">
					<xs:element name="i1" type="xs:int" dfdl:initiator="#:" minOccurs="1" maxOccurs="10"/>
				</xs:sequence>
			</xs:complexType>
		</xs:element>
    
    <xs:element name="occursCount1b">
			<xs:annotation>
				<xs:appinfo source="http://www.ogf.org/dfdl/">
					<dfdl:assert test="{ dfdl:occursCount( /ex:occursCount1/* ) eq 1 }"
						message="Assertion 
            failed for dfdl:occursCount( /ex:occursCount/* ) eq 1" />
				</xs:appinfo>
			</xs:annotation>
			<xs:complexType>
				<xs:sequence dfdl:separator=",">
					<xs:element name="i1" type="xs:int" dfdl:initiator="#:" minOccurs="1" maxOccurs="10"/>
				</xs:sequence>
			</xs:complexType>
		</xs:element>
    
    <xs:element name="occursCount2">
			<xs:complexType>
				<xs:sequence dfdl:separator=",">
          <xs:element name="array">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="i1" type="xs:int" dfdl:initiator="#:" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="occurs" type="xs:int" dfdl:inputValueCalc="{ dfdl:occursCount(/ex:occursCount2/ex:array/*) }"/>
				</xs:sequence>
			</xs:complexType>
		</xs:element>
    
    <xs:element name="occursCount3">
			<xs:complexType>
				<xs:sequence>
          <xs:element name="array">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="i1" type="xs:int" dfdl:initiator="#:" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="occurs" type="xs:int" dfdl:inputValueCalc="{ dfdl:occursCount(/ex:occursCount3/ex:array/ex:i1) }"/>
				</xs:sequence>
			</xs:complexType>
		</xs:element>

		<xs:element name="stringLiteralFromString">
			<xs:complexType>
				<xs:sequence>
					<xs:element name="str" type="xs:string"
						dfdl:representation="text" />
					<xs:element name="literal" type="xs:string"
						dfdl:lengthKind="implicit"
						dfdl:inputValueCalc="{ dfdl:stringLiteralFromString( ../ex:str/text()) }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>

		<xs:element name="containsEntity">
			<xs:complexType>
				<xs:sequence>
					<xs:element name="str" type="xs:string"
						dfdl:representation="text" />
					<xs:element name="hasEntity" type="xs:boolean"
						dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:containsEntity('TEST%NL;TEST') }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>
		
    <xs:element name="containsEntity1">
			<xs:complexType>
				<xs:sequence>
					<xs:element name="str" type="xs:string"	dfdl:representation="text" />
					<xs:element name="hasEntity" type="xs:boolean"
						dfdl:lengthKind="implicit" dfdl:inputValueCalc="{ dfdl:containsEntity(xs:string(/ex:containsEntity1/ex:str)) }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>
		
    <xs:element name="valueLength">
			<xs:complexType>
				<xs:sequence dfdl:separator=",">
					<xs:element name="str" type="xs:string"	dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar" 
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" />
					<xs:element name="valLen" type="xs:string"
						dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ dfdl:valueLength( ../ex:str/text(), 0) }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>
    
    <xs:element name="valueLength2">
			<xs:complexType>
				<xs:sequence dfdl:separator=",">
					<xs:element name="str" type="xs:string"	dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar" 
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" />
					<xs:element name="valLen" type="xs:string"
						dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ dfdl:valueLength( ../ex:str, 'bytes' ) }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>
    
    <xs:element name="contentLength">
			<xs:complexType>
				<xs:sequence dfdl:separator=",">
					<xs:element name="str" type="xs:string"	dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar" 
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" />
					<xs:element name="conLen" dfdl:representation="binary" dfdl:lengthKind="implicit" type="xs:unsignedLong"
						dfdl:inputValueCalc="{ dfdl:contentLength( ../ex:str, 'bytes' ) }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>
    
    <xs:element name="contentLength2">
			<xs:complexType>
				<xs:sequence dfdl:separator=",">
					<xs:element name="str" type="xs:string"	dfdl:lengthKind="delimited" dfdl:textTrimKind="padChar" 
            dfdl:textStringPadCharacter="/" dfdl:textStringJustification="center" />
					<xs:element name="conLen" dfdl:lengthKind="delimited" type="xs:string" dfdl:inputValueCalc="{ dfdl:contentLength( ../ex:str, 'characters' ) }" />
				</xs:sequence>
			</xs:complexType>
		</xs:element>

	</tdml:defineSchema>

<!--
    Test Name: testBit_0
       Schema: Functions.dfdl.xsd
         Root: testBit
      Purpose: This test demonstrates the use of the testBit function to turn bits into boolean values
-->

	<tdml:parserTestCase name="testBit_0" root="testBit"
		model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:testBit - DFDL-23-130R">

		<tdml:document>
			<tdml:documentPart type="bits">00000001
			</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<testBit>
					<byte>1</byte>
					<bit0>true</bit0>
					<bit7>false</bit7>
				</testBit>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: testBit_1
       Schema: Functions.dfdl.xsd
         Root: testBit1
      Purpose: This test demonstrates the use of the testBit function to turn bits into boolean values
-->

	<tdml:parserTestCase name="testBit_1" root="testBit1"
		model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:testBit - DFDL-23-130R">

		<tdml:document>
			<tdml:documentPart type="bits">00000111</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<testBit1>
					<byte>7</byte>
					<bit1>true</bit1>
					<bit2>true</bit2>
				</testBit1>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: testBit_2
       Schema: Functions.dfdl.xsd
         Root: testBit2
      Purpose: This test demonstrates the use of the testBit function to turn bits into boolean values
-->

	<tdml:parserTestCase name="testBit_2" root="testBit2"
		model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:testBit - DFDL-23-130R">

		<tdml:document>
			<tdml:documentPart type="bits">00000000 00000000 00000101 00010101</tdml:documentPart>
		</tdml:document>
    <tdml:errors>
      <tdml:error>Runtime Schema Definition Error</tdml:error>
      <tdml:error>dfdl:testBit $data must be an unsignedByte within the range of (0-255). $data was 1301</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
    Test Name: testBit_3
       Schema: Functions.dfdl.xsd
         Root: testBit3
      Purpose: This test demonstrates the creation of a runtime SDE by feeding an unexpected data type
-->

	<tdml:parserTestCase name="testBit_3" root="testBit"
		model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:testBit - DFDL-23-130R">

		<tdml:document>
			<tdml:documentPart type="bits">foobar</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>placeholder</tdml:error>
    </tdml:errors>
	</tdml:parserTestCase>


<!--
    Test Name: setBits_0
       Schema: Functions.dfdl.xsd
         Root: setBits
      Purpose: This test demonstrates the use of the setBits function to set the bits of a byte
-->

	<tdml:parserTestCase name="setBits_0" root="setBits"
		model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:setBits - DFDL-23-131R">

		<tdml:document>
			<tdml:documentPart type="bits">00000000
			</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<setBits>
					<e>0</e>
					<e0>1</e0>
					<e1>2</e1>
					<e2>4</e2>
					<e3>8</e3>
					<e4>16</e4>
					<e5>32</e5>
					<e6>64</e6>
					<e7>128</e7>
					<e8>255</e8>
				</setBits>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: setBits_1
       Schema: Functions.dfdl.xsd
         Root: setBits
      Purpose: This test demonstrates the misuse of the setBits function. The number of arguments is incorrect and the
               test should fail.
-->

	<tdml:parserTestCase name="setBits_1" root="setBits1"
		model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:setBits - DFDL-23-131R">

		<tdml:document>
			<tdml:documentPart type="bits">00000000</tdml:documentPart>
		</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>no such function</tdml:error>
      <tdml:error>setBits with arity 6</tdml:error>
    </tdml:errors>
	</tdml:parserTestCase>

<!--
    Test Name: setBits_2
       Schema: Functions.dfdl.xsd
         Root: setBits
      Purpose: This test demonstrates the use of the setBits function to set the bits of a byte
-->

	<tdml:parserTestCase name="setBits_2" root="setBits2"
		model="Functions.dfdl.xsd" description="Section 23 - Functions - dfdl:setBits - DFDL-23-131R">

		<tdml:document>
			<tdml:documentPart type="text">0,0,0,0,1,0,1,1</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<setBits2>
					<e0>0</e0>
					<e1>0</e1>
					<e2>0</e2>
					<e3>0</e3>
					<e4>1</e4>
					<e5>0</e5>
					<e6>1</e6>
					<e7>1</e7>
					<e>11</e>
				</setBits2>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: occursCount_0
       Schema: Functions.dfdl.xsd
         Root: occursCount
      Purpose: This test demonstrates the use of the occursCount function
-->

	<tdml:parserTestCase name="occursCount_0" root="occursCount"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[1,2,3]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<occursCount>
					<i1>1</i1>
					<i2>2</i2>
					<i3>3</i3>
				</occursCount>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: occursCount_1
       Schema: Functions.dfdl.xsd
         Root: occursCount1
      Purpose: This test demonstrates the use of the occursCount function
-->

	<tdml:parserTestCase name="occursCount_1" root="occursCount1"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[#:1,#:2,#:3]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<occursCount1>
					<i1>1</i1>
					<i1>2</i1>
					<i1>3</i1>
				</occursCount1>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: occursCount_1b
       Schema: Functions.dfdl.xsd
         Root: occursCount1b
      Purpose: This test demonstrates the use of the occursCount function
-->

	<tdml:parserTestCase name="occursCount_1b" root="occursCount1b"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[#:1]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<occursCount1>
					<i1>1</i1>
					<i1>2</i1>
					<i1>3</i1>
				</occursCount1>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: occursCount_2
       Schema: Functions.dfdl.xsd
         Root: occursCount2
      Purpose: This test demonstrates the use of the occursCount function
-->

	<tdml:parserTestCase name="occursCount_2" root="occursCount2"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[#:1,#:2,#:3,#:4,#:5]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <occursCount2>
          <array>
            <i1>1</i1>
            <i1>2</i1>
            <i1>3</i1>
            <i1>4</i1>
            <i1>5</i1>
          </array>
					<occurs>5</occurs>
				</occursCount2>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: occursCount_3
       Schema: Functions.dfdl.xsd
         Root: occursCount3
      Purpose: This test demonstrates the use of the occursCount function
-->

	<tdml:parserTestCase name="occursCount_3" root="occursCount3"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[#:1,#:2,#:3]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <occursCount3>
          <array>
            <i1>1</i1>
            <i1>2</i1>
            <i1>3</i1>
          </array>
					<occurs>3</occurs>
				</occursCount3>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: occursCount_3b
       Schema: Functions.dfdl.xsd
         Root: occursCount3
      Purpose: This test demonstrates the use of the occursCount function
               In this case there is only one occurrence.      
-->

	<tdml:parserTestCase name="occursCount_3b" root="occursCount3"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[#:1]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <occursCount3>
          <array>
            <i1>1</i1>
          </array>
					<occurs>1</occurs>
				</occursCount3>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: stringLiteralFromString_0
       Schema: Functions.dfdl.xsd
         Root: stringLiteralFromString
      Purpose: This test demonstrates the use of the stringLiteralFromString function
-->

	<tdml:parserTestCase name="stringLiteralFromString_0"
		root="stringLiteralFromString" model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[%This is a test!%]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<stringLiteralFromString>
					<str>%This is a test!%</str>
					<literal>%%This%SP;is%SP;a%SP;test!%%</literal>
				</stringLiteralFromString>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: stringLiteralFromString_1
       Schema: Functions.dfdl.xsd
         Root: stringLiteralFromString
      Purpose: This test demonstrates the use of the stringLiteralFromString function
-->

	<tdml:parserTestCase name="stringLiteralFromString_1"
		root="stringLiteralFromString" model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="byte"><![CDATA[30 04 31 09 32 0a 33 0b 34]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<stringLiteralFromString>
					<str>01 2 34</str>
					<literal>0%EOT;1%HT;2%LF;3%VT;4</literal>
				</stringLiteralFromString>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: stringLiteralFromString_2
       Schema: Functions.dfdl.xsd
         Root: stringLiteralFromString
      Purpose: This test demonstrates the use of the stringLiteralFromString function
-->

	<tdml:parserTestCase name="stringLiteralFromString_2"
		root="stringLiteralFromString" model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="byte"><![CDATA[01 07 33 0b 0a 09 08 34]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<stringLiteralFromString>
					<str>3 4</str>
					<literal>%SOH;%BEL;3%VT;%LF;%HT;%BS;4</literal>
				</stringLiteralFromString>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: containsEntity_0
       Schema: Functions.dfdl.xsd
         Root: containsEntity
      Purpose: This test demonstrates the use of the containsEntity function to determine if a string contains an entity
-->

	<tdml:parserTestCase name="containsEntity_0" root="containsEntity"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[%This is a test!%]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<containsEntity>
					<str>%This is a test!%</str>
					<hasEntity>true</hasEntity>
				</containsEntity>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: containsEntity_1
       Schema: Functions.dfdl.xsd
         Root: containsEntity1
      Purpose: This test demonstrates the use of the containsEntity function to determine if a string contains an entity
               In this case the string does not contain an entity
-->

	<tdml:parserTestCase name="containsEntity_1" root="containsEntity1"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[This is a test!]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<containsEntity1>
					<str>This is a test!</str>
					<hasEntity>false</hasEntity>
				</containsEntity1>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: containsEntity_2
       Schema: Functions.dfdl.xsd
         Root: containsEntity1
      Purpose: This test demonstrates the use of the containsEntity function to determine if a string contains an entity
               In this case the string contains an entity
-->

	<tdml:parserTestCase name="containsEntity_2" root="containsEntity1"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart replaceDFDLEntities="false" type="text">%NUL;%SOH;;;%%;</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<containsEntity1>
					<str>%NUL;%SOH;;;%%;</str>
					<hasEntity>true</hasEntity>
				</containsEntity1>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: containsEntity_3
       Schema: Functions.dfdl.xsd
         Root: containsEntity1
      Purpose: This test demonstrates the use of the containsEntity function to determine if a string contains an entity
               In this case the string contains an entity
-->

	<tdml:parserTestCase name="containsEntity_3" root="containsEntity1"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart replaceDFDLEntities="false" type="text">%NUL;%SP;-</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<containsEntity1>
				  <str>%NUL;%SP;-</str>
					<hasEntity>true</hasEntity>
				</containsEntity1>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: containsEntity_4
       Schema: Functions.dfdl.xsd
         Root: containsEntity1
      Purpose: This test demonstrates the use of the containsEntity function to determine if a string contains an entity
               In this case the string contains an entity
-->

	<tdml:parserTestCase name="containsEntity_4" root="containsEntity1"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart replaceDFDLEntities="false" type="text">%HT;%LF;</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<containsEntity1>
					<str>%HT;%LF;</str>
					<hasEntity>true</hasEntity>
				</containsEntity1>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: valueLength_0
       Schema: Functions.dfdl.xsd
         Root: valueLength
      Purpose: This test demonstrates the valueLength function (formerly unpaddedLength).
-->

	<tdml:parserTestCase name="valueLength_0" root="valueLength"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[////test////]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<valueLength>
					<str>test</str>
					<valLen>4</valLen>
				</valueLength>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: valueLength_1
       Schema: Functions.dfdl.xsd
         Root: valueLength2
      Purpose: This test demonstrates the valueLength function (formerly unpaddedLength).
-->

	<tdml:parserTestCase name="valueLength_1" root="valueLength2"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[////test////]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<valueLength2>
					<str>test</str>
					<valLen>4</valLen>
				</valueLength2>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: contentLength_0
       Schema: Functions.dfdl.xsd
         Root: contentLength
      Purpose: This test demonstrates the contentLength function (formerly representationLength).
-->

	<tdml:parserTestCase name="contentLength_0" root="contentLength"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[////test////]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<contentLength>
					<str>test</str>
					<conLen>12</conLen>
				</contentLength>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: contentLength_1
       Schema: Functions.dfdl.xsd
         Root: contentLength2
      Purpose: This test demonstrates the contentLength function (formerly representationLength).
-->

	<tdml:parserTestCase name="contentLength_1" root="contentLength2"
		model="Functions.dfdl.xsd" description="Section 23 ">

		<tdml:document>
			<tdml:documentPart type="text"><![CDATA[////test////]]></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset xmlns:xs="http://www.w3.org/2001/XMLSchema"
				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
				<contentLength2>
					<str>test</str>
					<conLen>12</conLen>
				</contentLength2>
			</tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
  <tdml:defineSchema name="XPathFunctions">
    <dfdl:format ref="ex:daffodilTest1"/>

    <xs:element name="abs" type="xs:int" dfdl:inputValueCalc="{ fn:abs(-9) }"/>

    <xs:element name="abs02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="absval" type="xs:int" dfdl:inputValueCalc="{ fn:abs(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="abs03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="absval" type="xs:int" dfdl:inputValueCalc="{ fn:abs(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="abs04">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element xmlns:tst="http://www.w3.org/2005/xpath-functions" name="absval" type="xs:int" dfdl:inputValueCalc="{ tst:abs(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ceil" type="xs:int" dfdl:inputValueCalc="{ fn:ceiling(4.2) }"/>

    <xs:element name="ceil02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="ceilval" type="xs:int" dfdl:inputValueCalc="{ fn:ceiling(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ceil03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="ceilval" type="xs:int" dfdl:inputValueCalc="{ fn:ceiling(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ceil04">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element xmlns:tst="http://www.w3.org/2005/xpath-functions" name="ceilval" type="xs:int" dfdl:inputValueCalc="{ tst:ceiling(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="floor" type="xs:int" dfdl:inputValueCalc="{ fn:floor(4.2) }"/>

    <xs:element name="floor02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="floorval" type="xs:int" dfdl:inputValueCalc="{ fn:floor(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="floor03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="floorval" type="xs:int" dfdl:inputValueCalc="{ fn:floor(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="floor04">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element xmlns:tst="http://www.w3.org/2005/xpath-functions" name="floorval" type="xs:int" dfdl:inputValueCalc="{ tst:floor(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round" type="xs:int" dfdl:inputValueCalc="{ fn:round(4.2) }"/>

    <xs:element name="round02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="roundval" type="xs:int" dfdl:inputValueCalc="{ fn:round(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="roundval" type="xs:int" dfdl:inputValueCalc="{ fn:round(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round04">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="val" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element xmlns:tst="http://www.w3.org/2005/xpath-functions" name="roundval" type="xs:int" dfdl:inputValueCalc="{ tst:round(../ex:val) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="round-hte">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="num" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="precision" type="xs:int" dfdl:lengthKind="delimited"/>
          <xs:element name="roundval" type="xs:float" dfdl:inputValueCalc="{ fn:round-half-to-even(../ex:num,../ex:precision) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

<!--
    Test Name: xPathFunc_abs_01
       Schema: XPathFunctions
         Root: abs
      Purpose: This test demonstrates abs (absolute value) function
-->

	<tdml:parserTestCase name="xPathFunc_abs_01" root="abs"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

		<tdml:document>
			<tdml:documentPart type="text"></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset>
        <abs>9</abs>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_abs_02
       Schema: XPathFunctions
         Root: abs02
      Purpose: This test demonstrates abs (absolute value) function
-->

	<tdml:parserTestCase name="xPathFunc_abs_02" root="abs02"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

		<tdml:document>
			<tdml:documentPart type="text">-30</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <abs02>
          <val>-30</val>
          <absval>30</absval>
        </abs02>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_abs_03
       Schema: XPathFunctions
         Root: abs03
      Purpose: This test demonstrates abs (absolute value) function
-->

	<tdml:parserTestCase name="xPathFunc_abs_03" root="abs03"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

		<tdml:document>
			<tdml:documentPart type="text">string</tdml:documentPart>
		</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "string" to a double</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_abs_04
       Schema: XPathFunctions
         Root: abs04
      Purpose: This test demonstrates abs (absolute value) function
-->

	<tdml:parserTestCase name="xPathFunc_abs_04" root="abs04"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - abs - DFDL-23-094R">

		<tdml:document>
			<tdml:documentPart type="text">-30</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <abs04>
          <val>-30</val>
          <absval>30</absval>
        </abs04>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>

<!--
    Test Name: xPathFunc_ceil_01
       Schema: XPathFunctions
         Root: ceil
      Purpose: This test demonstrates the ceiling function
-->

	<tdml:parserTestCase name="xPathFunc_ceil_01" root="ceil"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

		<tdml:document>
			<tdml:documentPart type="text"></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset>
        <ceil>5</ceil>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_ceil_02
       Schema: XPathFunctions
         Root: ceil02
      Purpose: This test demonstrates the ceiling function
-->

	<tdml:parserTestCase name="xPathFunc_ceil_02" root="ceil02"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

		<tdml:document>
			<tdml:documentPart type="text">6.1</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <ceil02>
          <val>6.1</val>
          <ceilval>7</ceilval>
        </ceil02>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_ceil_03
       Schema: XPathFunctions
         Root: ceil03
      Purpose: This test demonstrates the ceiling function
-->

	<tdml:parserTestCase name="xPathFunc_ceil_03" root="ceil03"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

		<tdml:document>
			<tdml:documentPart type="text">string</tdml:documentPart>
		</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "string" to a double</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_ceil_04
       Schema: XPathFunctions
         Root: ceil04
      Purpose: This test demonstrates the ceiling function
-->

	<tdml:parserTestCase name="xPathFunc_ceil_04" root="ceil04"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

		<tdml:document>
			<tdml:documentPart type="text">4.2</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <ceil04>
          <val>4.2</val>
          <ceilval>5</ceilval>
        </ceil04>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_ceil_05
       Schema: XPathFunctions
         Root: ceil04
      Purpose: This test demonstrates the ceiling function
-->

	<tdml:parserTestCase name="xPathFunc_ceil_05" root="ceil04"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - ceiling - DFDL-23-095R">

		<tdml:document>
			<tdml:documentPart type="text">-3.4</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <ceil04>
          <val>-3.4</val>
          <ceilval>-3</ceilval>
        </ceil04>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_floor_01
       Schema: XPathFunctions
         Root: floor
      Purpose: This test demonstrates the floor function
-->

	<tdml:parserTestCase name="xPathFunc_floor_01" root="floor"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">

		<tdml:document>
			<tdml:documentPart type="text"></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset>
        <floor>4</floor>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_floor_02
       Schema: XPathFunctions
         Root: floor02
      Purpose: This test demonstrates the floor function
-->

	<tdml:parserTestCase name="xPathFunc_floor_02" root="floor02"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">

		<tdml:document>
			<tdml:documentPart type="text">6.1</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <floor02>
          <val>6.1</val>
          <floorval>6</floorval>
        </floor02>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_floor_03
       Schema: XPathFunctions
         Root: floor03
      Purpose: This test demonstrates the floor function
-->

	<tdml:parserTestCase name="xPathFunc_floor_03" root="floor03"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">

		<tdml:document>
			<tdml:documentPart type="text">string</tdml:documentPart>
		</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "string" to a double</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_floor_04
       Schema: XPathFunctions
         Root: floor04
      Purpose: This test demonstrates the floor function
-->

	<tdml:parserTestCase name="xPathFunc_floor_04" root="floor04"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">

		<tdml:document>
			<tdml:documentPart type="text">4.2</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <floor04>
          <val>4.2</val>
          <floorval>4</floorval>
        </floor04>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_floor_05
       Schema: XPathFunctions
         Root: floor04
      Purpose: This test demonstrates the floor function
-->

	<tdml:parserTestCase name="xPathFunc_floor_05" root="floor04"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - floor - DFDL-23-096R">

		<tdml:document>
			<tdml:documentPart type="text">-3.4</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <floor04>
          <val>-3.4</val>
          <floorval>-4</floorval>
        </floor04>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_01
       Schema: XPathFunctions
         Root: round
      Purpose: This test demonstrates the round function
-->

	<tdml:parserTestCase name="xPathFunc_round_01" root="round"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

		<tdml:document>
			<tdml:documentPart type="text"></tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
			<tdml:dfdlInfoset>
        <round>4</round>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_02
       Schema: XPathFunctions
         Root: round02
      Purpose: This test demonstrates the round function
-->

	<tdml:parserTestCase name="xPathFunc_round_02" root="round02"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

		<tdml:document>
			<tdml:documentPart type="text">6.1</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round02>
          <val>6.1</val>
          <roundval>6</roundval>
        </round02>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_03
       Schema: XPathFunctions
         Root: round03
      Purpose: This test demonstrates the round function
-->

	<tdml:parserTestCase name="xPathFunc_round_03" root="round03"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

		<tdml:document>
			<tdml:documentPart type="text">string</tdml:documentPart>
		</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "string" to a double</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_04
       Schema: XPathFunctions
         Root: round04
      Purpose: This test demonstrates the round function
-->

	<tdml:parserTestCase name="xPathFunc_round_04" root="round04"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

		<tdml:document>
			<tdml:documentPart type="text">4.2</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round04>
          <val>4.2</val>
          <roundval>4</roundval>
        </round04>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_05
       Schema: XPathFunctions
         Root: round04
      Purpose: This test demonstrates the round function
-->

	<tdml:parserTestCase name="xPathFunc_round_05" root="round04"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

		<tdml:document>
			<tdml:documentPart type="text">-3.4</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round04>
          <val>-3.4</val>
          <roundval>-3</roundval>
        </round04>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_06
       Schema: XPathFunctions
         Root: round04
      Purpose: This test demonstrates the round function
-->

	<tdml:parserTestCase name="xPathFunc_round_06" root="round04"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round - DFDL-23-097R">

		<tdml:document>
			<tdml:documentPart type="text">.5</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round04>
          <val>.5</val>
          <roundval>1</roundval>
        </round04>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_01
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function
-->

	<tdml:parserTestCase name="xPathFunc_round_hte_01" root="round-hte"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

		<tdml:document>
			<tdml:documentPart type="text">3.45,0</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.45</num>
          <precision>0</precision>
          <roundval>3.0</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_02
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.455 and we're rounding to the hundredths place.
               Since our determining value is a 5, we round the digit in the hundredths place to the even value - 6 in this case. 
-->

	<tdml:parserTestCase name="xPathFunc_round_hte_02" root="round-hte"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

		<tdml:document>
			<tdml:documentPart type="text">3.455,2</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.455</num>
          <precision>2</precision>
          <roundval>3.46</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_03
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.0000065 and we're rounding to the 6th digit.
               Since our determining value is a 5, we round the 6th digit to the even value - 6 in this case. 
-->

	<tdml:parserTestCase name="xPathFunc_round_hte_03" root="round-hte"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

		<tdml:document>
			<tdml:documentPart type="text">3.0000065,6</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.0000065</num>
          <precision>6</precision>
          <roundval>3.000006</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_04
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.000065 and we're rounding to the 4th digit.
               Since our determining value is a 5, we round the 4th digit to the even value - 6 in this case. 
-->

	<tdml:parserTestCase name="xPathFunc_round_hte_04" root="round-hte"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

		<tdml:document>
			<tdml:documentPart type="text">3.00065,4</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.00065</num>
          <precision>4</precision>
          <roundval>3.0006</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_05
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.000065 and we're rounding to the 5th digit.
               Since our determining value is a 5, we round the 5th digit to the even value - 6 in this case. 
-->

	<tdml:parserTestCase name="xPathFunc_round_hte_05" root="round-hte"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

		<tdml:document>
			<tdml:documentPart type="text">3.000065,5</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.000065</num>
          <precision>5</precision>
          <roundval>3.00006</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_06
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.0000064 and we're rounding to the 6th digit.
-->

	<tdml:parserTestCase name="xPathFunc_round_hte_06" root="round-hte"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

		<tdml:document>
			<tdml:documentPart type="text">3.0000064,6</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.0000064</num>
          <precision>6</precision>
          <roundval>3.000006</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_07
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.0000075 and we're rounding to the 6th digit.
-->

	<tdml:parserTestCase name="xPathFunc_round_hte_07" root="round-hte"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

		<tdml:document>
			<tdml:documentPart type="text">3.0000075,6</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.0000075</num>
          <precision>6</precision>
          <roundval>3.000008</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
<!--
    Test Name: xPathFunc_round_hte_08
       Schema: XPathFunctions
         Root: round-hte
      Purpose: This test demonstrates the round-half-to-even function. Our data is 3.00000075 and we're rounding to the 7th digit.
-->

	<tdml:parserTestCase name="xPathFunc_round_hte_08" root="round-hte"
		model="XPathFunctions" description="Section 23.5.2 - Standard XPath Functions - round-half-to-even - DFDL-23-098R">

		<tdml:document>
			<tdml:documentPart type="text">3.00000075,7</tdml:documentPart>
		</tdml:document>
		<tdml:infoset>
      <tdml:dfdlInfoset>
        <round-hte>
          <num>3.00000075</num>
          <precision>7</precision>
          <roundval>3.0000008</roundval>
        </round-hte>
      </tdml:dfdlInfoset>
		</tdml:infoset>
	</tdml:parserTestCase>
  
  <tdml:defineSchema name="constructorSchema">
    <dfdl:format ref="daffodilTest1" />

    <xs:element name="integer01" type="xs:integer" dfdl:inputValueCalc="{ xs:integer(45.4) }"/>
    <xs:element name="integer02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="intified" type="xs:integer" dfdl:inputValueCalc="{ xs:integer(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="integer03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="float" type="xs:float" dfdl:lengthKind="delimited"/>
          <xs:element name="intified" type="xs:integer" dfdl:inputValueCalc="{ xs:integer(../ex:float) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="integer04" type="xs:integer" dfdl:inputValueCalc="{ xs:integer(xs:float(45.4)) }"/>
    
    <xs:element name="dateTime01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MM-dd-yyyy"/>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ss"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ fn:dateTime(../ex:date, ../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MMMM-dd-yy"/>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ssZ"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ fn:dateTime(fn:adjust-date-to-timezone(../ex:date, fn:timezone-from-time(../ex:time)), ../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime03">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="date" type="xs:date" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="MMMM-dd-yyZ"/>
          <xs:element name="time" type="xs:time" dfdl:lengthKind="delimited" dfdl:calendarPatternKind="explicit" dfdl:calendarPattern="hh:mm:ssZ"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ fn:dateTime(../ex:date, ../ex:time) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="dateTime04">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="dateTime" type="xs:dateTime" dfdl:inputValueCalc="{ xs:dateTime(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="time01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="time" type="xs:time" dfdl:inputValueCalc="{ xs:time(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="date01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="date" type="xs:date" dfdl:inputValueCalc="{ xs:date(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="hexBinary01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="hexBinary" type="xs:hexBinary" dfdl:inputValueCalc="{ xs:hexBinary(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="byte01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="byte" type="xs:byte" dfdl:inputValueCalc="{ xs:byte(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="int01" type="xs:int" dfdl:inputValueCalc="{ xs:int(45.2) }"/>
    <xs:element name="int02" type="xs:int" dfdl:inputValueCalc="{ xs:int(60) }"/>
    <xs:element name="int03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="intified" type="xs:int" dfdl:inputValueCalc="{ xs:int(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="int04" type="xs:int" dfdl:inputValueCalc="{ xs:int(-60) }"/>
    
    <xs:element name="long01" type="xs:long" dfdl:inputValueCalc="{ xs:long(-50) }"/>
    <xs:element name="long02" type="xs:long" dfdl:inputValueCalc="{ xs:long(12345678987654321) }"/>
    <xs:element name="long03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="longified" type="xs:long" dfdl:inputValueCalc="{ xs:long(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ulong01" type="xs:unsignedLong" dfdl:inputValueCalc="{ xs:unsignedLong(-50) }"/>
    <xs:element name="ulong02" type="xs:unsignedLong" dfdl:inputValueCalc="{ xs:unsignedLong(12345678987654321) }"/>
    <xs:element name="ulong03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="ulongified" type="xs:unsignedLong" dfdl:inputValueCalc="{ xs:unsignedLong(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ushort01" type="xs:unsignedShort" dfdl:inputValueCalc="{ xs:unsignedShort(-50) }"/>
    <xs:element name="ushort02" type="xs:unsignedShort" dfdl:inputValueCalc="{ xs:unsignedShort(12345678987654321) }"/>
    <xs:element name="ushort03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="ushortified" type="xs:unsignedShort" dfdl:inputValueCalc="{ xs:unsignedShort(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="short01" type="xs:short" dfdl:inputValueCalc="{ xs:short(-50) }"/>
    <xs:element name="short02" type="xs:short" dfdl:inputValueCalc="{ xs:short(12345678987654321) }"/>
    <xs:element name="short03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="shortified" type="xs:short" dfdl:inputValueCalc="{ xs:short(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="short04">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:representation="binary" dfdl:lengthKind="delimited"/>
          <xs:element name="shortified" type="xs:short" dfdl:inputValueCalc="{ xs:short(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="decimal01" type="xs:decimal" dfdl:inputValueCalc="{ xs:decimal(45.2) }"/>
    <xs:element name="decimal02" type="xs:decimal" dfdl:inputValueCalc="{ xs:decimal(60) }"/>
    <xs:element name="decimal03">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="decified" type="xs:decimal" dfdl:inputValueCalc="{ xs:decimal(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="decimal04" type="xs:decimal" dfdl:inputValueCalc="{ xs:decimal(-60) }"/>
    
    <xs:element name="float01">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="floatified" type="xs:float" dfdl:inputValueCalc="{ xs:float(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="float02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="string2" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="floatified" type="xs:float" dfdl:inputValueCalc="{ xs:float(../ex:string + ../ex:string2) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="double01">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="doublified" type="xs:double" dfdl:inputValueCalc="{ xs:double(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="double02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="string2" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="doublified" type="xs:double" dfdl:inputValueCalc="{ xs:double(../ex:string + ../ex:string2) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="nonNeg01">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="string2" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="nonNeg" type="xs:integer" dfdl:inputValueCalc="{ xs:nonNegativeInteger(../ex:string + ../ex:string2) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="nonNeg02">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="nonNeg" type="xs:integer" dfdl:inputValueCalc="{ xs:nonNegativeInteger(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="uint01">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="string" type="xs:string" dfdl:lengthKind="delimited"/>
          <xs:element name="uintified" type="xs:unsignedLong" dfdl:inputValueCalc="{ xs:unsignedInt(../ex:string) }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>
  
  <!--
    Test name: integer_constructor_01
       Schema: constructorSchema
         Root: integer01
      Purpose: This tests demonstrates the use of the xs:integer constructor function and its ability to
               convert a fractional number to an integer
  -->

  <tdml:parserTestCase name="integer_constructor_01" root="integer01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer01>45</integer01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_02
       Schema: constructorSchema
         Root: integer02
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a string representation
               of an integer to an integer type
  -->

  <tdml:parserTestCase name="integer_constructor_02" root="integer02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text">184</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer02>
          <string>184</string>
          <intified>184</intified>
        </integer02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_03
       Schema: constructorSchema
         Root: integer02
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a string representation
               of an integer to an integer type. In this case the string cannot be converted to an integer and an error should occur.
  -->

  <tdml:parserTestCase name="integer_constructor_03" root="integer02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text">forty-eight</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "forty-eight" to an integer</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_04
       Schema: constructorSchema
         Root: integer02
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a string representation
               of an integer to an integer type
  -->

  <tdml:parserTestCase name="integer_constructor_04" root="integer02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text">-184</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer02>
          <string>-184</string>
          <intified>-184</intified>
        </integer02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_05
       Schema: constructorSchema
         Root: integer02
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a string representation
               of a fractional number to an integer type
  -->

  <tdml:parserTestCase name="integer_constructor_05" root="integer02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text">-184.7</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer02>
          <string>-184.7</string>
          <intified>-185</intified>
        </integer02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_06
       Schema: constructorSchema
         Root: integer03
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a string representation
               of a fractional number to an integer type
  -->

  <tdml:parserTestCase name="integer_constructor_06" root="integer03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text">45.4</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer02>
          <float>45.4</float>
          <intified>45</intified>
        </integer02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: integer_constructor_07
       Schema: constructorSchema
         Root: integer04
      Purpose: This tests demonstrates the use of the xs:integer constructor function to convert a float representation
               of a fractional number to an integer type
  -->

  <tdml:parserTestCase name="integer_constructor_07" root="integer04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:integer()  - DFDL-23-078R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <integer04>45</integer04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: fnDateTime_constructor_01
       Schema: constructorSchema
         Root: dateTime01
      Purpose: This tests demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_01" root="dateTime01" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">03-31-1996,04:55:30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime01>
          <date>1996-03-31+00:00</date>
          <time>04:55:30.000000+00:00</time>
          <dateTime>1996-03-31T04:55:30.000000+00:00</dateTime>
        </dateTime01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: fnDateTime_constructor_02
       Schema: constructorSchema
         Root: dateTime01
      Purpose: This tests demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_02" root="dateTime01" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">01-31-1996,04:55:30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime01>
          <date>1996-01-31+00:00</date>
          <time>04:55:30.000000+00:00</time>
          <dateTime>1996-01-31T04:55:30.000000+00:00</dateTime>
        </dateTime01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: fnDateTime_constructor_03
       Schema: constructorSchema
         Root: dateTime02
      Purpose: This tests demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_03" root="dateTime02" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">March-31-96,04:55:30-0800</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime01>
          <date>1996-03-31+00:00</date>
          <time>04:55:30.000000-08:00</time>
          <dateTime>1996-03-30T04:55:30.000000-08:00</dateTime>
        </dateTime01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: fnDateTime_constructor_04
       Schema: constructorSchema
         Root: dateTime03
      Purpose: This tests demonstrates the use of the fn:dateTime constructor function to convert an xs:date and an 
               xs:time into an xs:dateTime
  -->

  <tdml:parserTestCase name="fnDateTime_constructor_04" root="dateTime03" model="constructorSchema"
    description="Section 23 - Constructor Functions - fn:dateTime()  - DFDL-23-089R">

    <tdml:document>
      <tdml:documentPart type="text">March-31-96-0800,04:55:30-0800</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
          <dateTime03>
            <date>1996-03-31-08:00</date>
            <time>04:55:30.000000-08:00</time>
            <dateTime>1996-03-31T04:55:30-08:00</dateTime>
          </dateTime03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: int_constructor_01
       Schema: constructorSchema
         Root: int01
      Purpose: This test demonstrates the use of the xs:int constructor function and its ability to
               convert a fractional number to an int
  -->

  <tdml:parserTestCase name="int_constructor_01" root="int01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:int()  - DFDL-23-080R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <int01>45</int01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: int_constructor_02
       Schema: constructorSchema
         Root: int02
      Purpose: This test demonstrates the use of the xs:int constructor function and its ability to
               convert a value to an int type
  -->

  <tdml:parserTestCase name="int_constructor_02" root="int02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:int()  - DFDL-23-080R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <int02>60</int02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: int_constructor_03
       Schema: constructorSchema
         Root: int03
      Purpose: This test demonstrates the use of the xs:int constructor function and its ability to
               convert a parsed value into an int
  -->

  <tdml:parserTestCase name="int_constructor_03" root="int03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:int()  - DFDL-23-080R">

    <tdml:document>
      <tdml:documentPart type="text">44444444</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <int03>
          <string>44444444</string>
          <intified>44444444</intified>
        </int03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: int_constructor_04
       Schema: constructorSchema
         Root: int03
      Purpose: This test demonstrates the use of the xs:int constructor function and its ability to
               convert a parsed value into an int. In this case the data is invalid and an error should occur.
  -->

  <tdml:parserTestCase name="int_constructor_04" root="int03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:int()  - DFDL-23-080R">

    <tdml:document>
      <tdml:documentPart type="text">not an int!</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Expression evaluation failed</tdml:error>
      <tdml:error>Cannot convert string "not an int!" to an integer</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_constructor_01
       Schema: constructorSchema
         Root: long01
      Purpose: This test demonstrates the use of the xs:long constructor function and its ability to
               convert a number to a long
  -->

  <tdml:parserTestCase name="long_constructor_01" root="long01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:long()  - DFDL-23-079R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <long01>-50</long01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_constructor_02
       Schema: constructorSchema
         Root: long02
      Purpose: This test demonstrates the use of the xs:long constructor function and its ability to
               convert a number to a long
  -->

  <tdml:parserTestCase name="long_constructor_02" root="long02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:long()  - DFDL-23-079R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <long02>12345678987654321</long02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_constructor_03
       Schema: constructorSchema
         Root: long03
      Purpose: This test demonstrates the use of the xs:long constructor function and its ability to
               convert a string (numeric) to a long
  -->

  <tdml:parserTestCase name="long_constructor_03" root="long03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:long()  - DFDL-23-079R">

    <tdml:document>
      <tdml:documentPart type="text">123456789</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <long03>
          <string>123456789</string>
          <longified>123456789</longified>
        </long03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_constructor_04
       Schema: constructorSchema
         Root: long04
      Purpose: This test demonstrates that if you provide a non-numeric string to the long constructor you get an appropriate error
  -->

  <tdml:parserTestCase name="long_constructor_04" root="long03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:long()  - DFDL-23-079R">

    <tdml:document>
      <tdml:documentPart type="text">not longable</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "not longable"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ulong_constructor_01
       Schema: constructorSchema
         Root: ulong01
      Purpose: This test demonstrates the use of the xs:unsignedLong constructor function and its ability to
               convert a number to an unsigned long
  -->

  <tdml:parserTestCase name="ulong_constructor_01" root="ulong01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedLong()  - DFDL-23-084R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value -50 cannot be converted to integer subtype xs:unsignedLong</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ulong_constructor_02
       Schema: constructorSchema
         Root: ulong02
      Purpose: This test demonstrates the use of the xs:unsignedLong constructor function and its ability to
               convert a number to an unsigned long
  -->

  <tdml:parserTestCase name="ulong_constructor_02" root="ulong02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedLong()  - DFDL-23-084R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ulong02>12345678987654321</ulong02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: ulong_constructor_03
       Schema: constructorSchema
         Root: ulong03
      Purpose: This test demonstrates the use of the xs:unsignedLong constructor function and its ability to
               convert a string (numeric) to an unsigned Long
  -->

  <tdml:parserTestCase name="ulong_constructor_03" root="ulong03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedLong()  - DFDL-23-084R">

    <tdml:document>
      <tdml:documentPart type="text">123456789</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ulong03>
          <string>123456789</string>
          <ulongified>123456789</ulongified>
        </ulong03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: ulong_constructor_04
       Schema: constructorSchema
         Root: ulong04
      Purpose: This test demonstrates that if you provide a non-numeric string to the unsigned long constructor you get an appropriate error
  -->

  <tdml:parserTestCase name="ulong_constructor_04" root="ulong03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedLong()  - DFDL-23-084R">

    <tdml:document>
      <tdml:documentPart type="text">not longable</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "not longable"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ulong_constructor_05
       Schema: constructorSchema
         Root: ulong03
      Purpose: This test demonstrates the use of the xs:unsignedLong constructor function and its ability to
               convert a string (numeric) to an unsigned Long. The max value for an unsigned long is 18,446,744,073,709,551,615, 
               so this test should fail.
  -->

  <tdml:parserTestCase name="ulong_constructor_05" root="ulong03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedLong()  - DFDL-23-084R">

    <tdml:document>
      <tdml:documentPart type="text">18446744073709551616</tdml:documentPart>
    </tdml:document>
      <tdml:errors>
        <tdml:error>Parse Error</tdml:error>
        <tdml:error>Integer value is out of range for subtype xs:unsignedLong</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ushort_constructor_01
       Schema: constructorSchema
         Root: ushort01
      Purpose: This test demonstrates the use of the xs:unsignedShort constructor function and its ability to
               convert a number to an unsigned short
  -->

  <tdml:parserTestCase name="ushort_constructor_01" root="ushort01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedShort()  - DFDL-23-086R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value -50 cannot be converted to integer subtype xs:unsignedShort</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ushort_constructor_02
       Schema: constructorSchema
         Root: ushort02
      Purpose: This test demonstrates the use of the xs:unsignedShort constructor function and its ability to
               convert a number to an unsigned short
  -->

  <tdml:parserTestCase name="ushort_constructor_02" root="ushort02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedShort()  - DFDL-23-086R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value 12345678987654321 cannot be converted to integer subtype xs:unsignedShort</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ushort_constructor_03
       Schema: constructorSchema
         Root: ushort03
      Purpose: This test demonstrates the use of the xs:unsignedShort constructor function and its ability to
               convert a string (numeric) to an unsigned short
  -->

  <tdml:parserTestCase name="ushort_constructor_03" root="ushort03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedShort()  - DFDL-23-086R">

    <tdml:document>
      <tdml:documentPart type="text">65535</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ushort03>
          <string>65535</string>
          <ushortified>65535</ushortified>
        </ushort03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: ushort_constructor_04
       Schema: constructorSchema
         Root: ushort03
      Purpose: This test demonstrates the use of the xs:unsignedShort constructor function and its ability to
               convert a string (numeric) to an unsigned short
  -->

  <tdml:parserTestCase name="ushort_constructor_04" root="ushort03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedShort()  - DFDL-23-086R">

    <tdml:document>
      <tdml:documentPart type="text">65536</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Value 65536 cannot be converted to integer subtype xs:unsignedShort</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: ushort_constructor_05
       Schema: constructorSchema
         Root: ushort04
      Purpose: This test demonstrates that if you provide a non-numeric string to the unsigned short constructor you get an appropriate error
  -->

  <tdml:parserTestCase name="ushort_constructor_05" root="ushort03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedShort()  - DFDL-23-086R">

    <tdml:document>
      <tdml:documentPart type="text">not shortable</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "not shortable"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
    Test name: short_constructor_01
       Schema: constructorSchema
         Root: short01
      Purpose: This test demonstrates the use of the xs:short constructor function and its ability to
               convert a number to an unsigned short
  -->

  <tdml:parserTestCase name="short_constructor_01" root="short01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <short01>-50</short01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: short_constructor_02
       Schema: constructorSchema
         Root: short02
      Purpose: This test demonstrates the use of the xs:short constructor function and its ability to
               convert a number to a short
  -->

  <tdml:parserTestCase name="short_constructor_02" root="short02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value 12345678987654321 cannot be converted to integer subtype xs:short</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: short_constructor_03
       Schema: constructorSchema
         Root: short03
      Purpose: This test demonstrates the use of the xs:short constructor function and its ability to
               convert a string (numeric) to a short
  -->

  <tdml:parserTestCase name="short_constructor_03" root="short03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="text">-32768</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <short03>
          <string>-32768</string>
          <shortified>-32768</shortified>
        </short03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: short_constructor_04
       Schema: constructorSchema
         Root: short03
      Purpose: This test demonstrates the use of the xs:short constructor function and its ability to
      convert a string (numeric) to a short. The range for short is -32768 to 32767 so this
      test should fail with a parse error.
  -->

  <tdml:parserTestCase name="short_constructor_04" root="short03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="text">-32769</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Value -32769 cannot be converted to integer subtype xs:short</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: short_constructor_05
       Schema: constructorSchema
         Root: short04
      Purpose: This test demonstrates that if you provide a non-numeric string to the unsigned short constructor you get an appropriate error
  -->

  <tdml:parserTestCase name="short_constructor_05" root="short03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="text">not shortable</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "not shortable"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: short_constructor_06
       Schema: constructorSchema
         Root: short04
      Purpose: This test demonstrates the use of the xs:short constructor function and its ability to
               convert a string (numeric - binary rep) to a short
  -->

  <tdml:parserTestCase name="short_constructor_06" root="short04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:short()  - DFDL-23-081R">

    <tdml:document>
      <tdml:documentPart type="bits">00101101 00110011 00110010 00110111 00110110 00111000</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <short04>
          <string>-32768</string>
          <shortified>-32768</shortified>
        </short04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_01
       Schema: constructorSchema
         Root: decimal01
      Purpose: This test demonstrates the use of the xs:decimal constructor function and its ability to
               convert a number to a decimal
  -->

  <tdml:parserTestCase name="decimal_constructor_01" root="decimal01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal01>45.2</decimal01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_02
       Schema: constructorSchema
         Root: decimal02
      Purpose: This test demonstrates the use of the xs:decimal constructor function and its ability to
               convert a number to a decimal
  -->

  <tdml:parserTestCase name="decimal_constructor_02" root="decimal02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal02>60</decimal02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_03
       Schema: constructorSchema
         Root: decimal03
      Purpose: This test demonstrates the use of the xs:decimal constructor function and its ability to
               convert a string (numeric) to a decimal
  -->

  <tdml:parserTestCase name="decimal_constructor_03" root="decimal03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text">0.123456789</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal03>
          <string>0.123456789</string>
          <decified>0.123456789</decified>
        </decimal03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_04
       Schema: constructorSchema
         Root: decimal03
      Purpose: This test demonstrates that if you provide a non-numeric string to the unsigned short constructor you get an appropriate error
  -->

  <tdml:parserTestCase name="decimal_constructor_04" root="decimal03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text">not decimalable</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "not decimalable"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_05
       Schema: constructorSchema
         Root: decimal04
      Purpose: This test demonstrates that the xs:decimal constructor can handle negative values
  -->

  <tdml:parserTestCase name="decimal_constructor_05" root="decimal04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text"></tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal04>-60</decimal04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: decimal_constructor_06
       Schema: constructorSchema
         Root: decimal03
      Purpose: This test demonstrates the use of the xs:decimal constructor function and its ability to
               convert a string (numeric) to a decimal
  -->

  <tdml:parserTestCase name="decimal_constructor_06" root="decimal03" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:decimal()  - DFDL-23-071R">

    <tdml:document>
      <tdml:documentPart type="text">0.1234567898765432123456789</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <decimal03>
          <string>0.1234567898765432123456789</string>
          <decified>0.1234567898765432123456789</decified>
        </decimal03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: float_constructor_01
       Schema: constructorSchema
         Root: float01
      Purpose: This test demonstrates the use of the xs:float constructor function and its ability to
               convert a number to a float
  -->

  <tdml:parserTestCase name="float_constructor_01" root="float01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:float()  - DFDL-23-072R">

    <tdml:document>
      <tdml:documentPart type="text">4.3</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <float01>
          <string>4.3</string>
          <floatified>4.3</floatified>
        </float01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: float_constructor_02
       Schema: constructorSchema
         Root: float02
      Purpose: This test demonstrates the use of the xs:float constructor function and its ability to
               convert a string (numeric) to a float
  -->

  <tdml:parserTestCase name="float_constructor_02" root="float02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:float()  - DFDL-23-072R">

    <tdml:document>
      <tdml:documentPart type="text">4.3,1.5</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <float02>
          <string>4.3</string>
          <string2>1.5</string2>
          <floatified>5.8</floatified>
        </float02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: float_constructor_03
       Schema: constructorSchema
         Root: float02
      Purpose: This test demonstrates the use of the xs:float constructor function and its ability to
      convert a string (numeric) to a float. In this case we are trying to add a non-numeric
      string to a numeric one, which should result in an error.
  -->

  <tdml:parserTestCase name="float_constructor_03" root="float02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:float()  - DFDL-23-072R">

    <tdml:document>
      <tdml:documentPart type="text">4.3,one</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "one"</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: float_constructor_04
       Schema: constructorSchema
         Root: float02
      Purpose: This test demonstrates the use of the xs:float constructor function and its ability to
               convert a string (numeric) to a float
  -->

  <tdml:parserTestCase name="float_constructor_04" root="float02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:float()  - DFDL-23-072R">

    <tdml:document>
      <tdml:documentPart type="text">4.3,1.987654</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <float02>
          <string>4.3</string>
          <string2>1.987654</string2>
          <floatified>6.287654</floatified>
        </float02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_01
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number to a double
  -->

  <tdml:parserTestCase name="double_constructor_01" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">4.3</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double01>
          <string>4.3</string>
          <doublified>4.3</doublified>
        </double01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_02
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number to a double. This test demonstrates that the limit for double is 15 decimal places.
  -->

  <tdml:parserTestCase name="double_constructor_02" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">4.10101010101010101019</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double01>
          <string>4.10101010101010101019</string>
          <doublified>4.101010101010101</doublified>
        </double01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_03
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number to a double. This test demonstrates that the limit for double is 15 decimal places.
  -->

  <tdml:parserTestCase name="double_constructor_03" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">123456789.11111111111111911111</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double01>
          <string>123456789.11111111111111911111</string>
          <doublified>1.234567891111111E8</doublified>
        </double01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_04
       Schema: constructorSchema
         Root: double02
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number to a double.
  -->

  <tdml:parserTestCase name="double_constructor_04" root="double02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">10000000000.40,10000000000.30</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double02>
          <string>10000000000.40</string>
          <string2>10000000000.30</string2>
          <doublified>2.0000000000699997E10</doublified>
        </double02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_05
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number (scientific notation) to a double.
  -->

  <tdml:parserTestCase name="double_constructor_05" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">1.123456789E9</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double01>
          <string>1.123456789E9</string>
          <doublified>1.123456789E9</doublified>
        </double01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_06
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number (scientific notation) to a double.
  -->

  <tdml:parserTestCase name="double_constructor_06" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">1.23E</tdml:documentPart>
    </tdml:document>
      <tdml:errors>
        <tdml:error>Parse Error</tdml:error>
        <tdml:error>Cannot convert string "1.23E" to a double</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_constructor_07
       Schema: constructorSchema
         Root: double01
      Purpose: This test demonstrates the use of the xs:double constructor function and its ability to
               convert a number (scientific notation) to a double.
  -->

  <tdml:parserTestCase name="double_constructor_07" root="double01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:double()  - DFDL-23-073R">

    <tdml:document>
      <tdml:documentPart type="text">1.23E-9</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <double01>
          <string>1.23E-9</string>
          <doublified>1.23E-9</doublified>
        </double01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_01
       Schema: constructorSchema
         Root: dateTime04
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a string to a dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_01" root="dateTime04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text">1996-02-04T12:30:34</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime04>
          <string>1996-02-04T12:30:34</string>
          <dateTime>1996-02-04T12:30:34</dateTime>
        </dateTime04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_02
       Schema: constructorSchema
         Root: dateTime04
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a string to a dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_02" root="dateTime04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text">02-03-1998T12:30:34</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid dateTime value "02-03-1998T12:30:34" (Year is less than four digits)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_03
       Schema: constructorSchema
         Root: dateTime04
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a string to a dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_03" root="dateTime04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text">1998-03-04T12:30:34.123456+00:00</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <dateTime04>
          <string>1998-03-04T12:30:34.123456+00:00</string>
          <dateTime>1998-03-04T12:30:34.123456+00:00</dateTime>
        </dateTime04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_04
       Schema: constructorSchema
         Root: dateTime04
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a string to a dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_04" root="dateTime04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text">1996-03-04T28:30:34</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid dateTime value "1996-03-04T28:30:34" (Hour is out of range)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: xsDateTime_constructor_05
       Schema: constructorSchema
         Root: dateTime04
      Purpose: This test demonstrates the use of the xs:dateTime constructor function and its ability to
               convert a string to a dateTime
  -->

  <tdml:parserTestCase name="xsDateTime_constructor_05" root="dateTime04" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:dateTime()  - DFDL-23-074R">

    <tdml:document>
      <tdml:documentPart type="text">about four-thirty or so, on a Wednesday in June.</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid dateTime value "about four-thirty or so" (Non-numeric year component)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_01
       Schema: constructorSchema
         Root: time01
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               convert a string to a time
  -->

  <tdml:parserTestCase name="time_constructor_01" root="time01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text">12:49:00</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <time01>
          <string>12:49:00</string>
          <time>12:49:00</time>
        </time01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_02
       Schema: constructorSchema
         Root: time01
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               convert a string to a time. In this case the time is invalid and an error should occur
  -->

  <tdml:parserTestCase name="time_constructor_02" root="time01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text">03:61:00</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid time "03:61:00" (minute is out of range)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_03
       Schema: constructorSchema
         Root: time01
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               convert a string to a time. In this case the time is invalid and an error should occur
  -->

  <tdml:parserTestCase name="time_constructor_03" root="time01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text">03:61:00</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid time "03:61:00" (minute is out of range)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: time_constructor_04
       Schema: constructorSchema
         Root: time01
      Purpose: This test demonstrates the use of the xs:time constructor function and its ability to
               construct a time from a string. In this case the string is not valid and an error will occur.
  -->

  <tdml:parserTestCase name="time_constructor_04" root="time01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:time()  - DFDL-23-075R">

    <tdml:document>
      <tdml:documentPart type="text">five o'clock</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid time "five o'clock" (hour must be two digits)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_01
       Schema: constructorSchema
         Root: date01
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               construct a date from a string. In this case the string is not valid and an error will occur.
  -->

  <tdml:parserTestCase name="date_constructor_01" root="date01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text">1991-03-4</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid date "1991-03-4" (Day must be two digits)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_02
       Schema: constructorSchema
         Root: date01
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               construct a date from a string.
  -->

  <tdml:parserTestCase name="date_constructor_02" root="date01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text">1991-03-04</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <date01>
          <string>1991-03-04</string>
          <date>1991-03-04</date>
        </date01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_03
       Schema: constructorSchema
         Root: date01
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               construct a date from a string.
  -->

  <tdml:parserTestCase name="date_constructor_03" root="date01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text">1991-03-045</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid date "1991-03-045" (Day must be two digits)</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: date_constructor_04
       Schema: constructorSchema
         Root: date01
      Purpose: This test demonstrates the use of the xs:date constructor function and its ability to
               construct a date from a string.
  -->

  <tdml:parserTestCase name="date_constructor_04" root="date01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:date()  - DFDL-23-076R">

    <tdml:document>
      <tdml:documentPart type="text">2013-03-04</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <date01>
          <string>2013-03-04</string>
          <date>2013-03-04</date>
        </date01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: hexBinary_constructor_01
       Schema: constructorSchema
         Root: hexBinary01
      Purpose: This test demonstrates the use of the xs:hexBinary constructor function and its ability to
               construct a hexBinary string from a string.
  -->

  <tdml:parserTestCase name="hexBinary_constructor_01" root="hexBinary01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text">ABCDEF123456</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <hexBinary01>
          <string>ABCDEF123456</string>
          <hexBinary>ABCDEF123456</hexBinary>
        </hexBinary01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: hexBinary_constructor_02
       Schema: constructorSchema
         Root: hexBinary01
      Purpose: This test demonstrates the use of the xs:hexBinary constructor function and its ability to
      construct a hexBinary string from a string. In this case the length of the hexBinary is not even and 
      an error will occur.
  -->

  <tdml:parserTestCase name="hexBinary_constructor_02" root="hexBinary01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text">ABCDEF12345</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>A hexBinary value must contain an even number of characters</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: hexBinary_constructor_03
       Schema: constructorSchema
         Root: hexBinary01
      Purpose: This test demonstrates the use of the xs:hexBinary constructor function and its ability to
      construct a hexBinary string from a string. 
  -->

  <tdml:parserTestCase name="hexBinary_constructor_03" root="hexBinary01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text">abcdef123456</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <hexBinary01>
          <string>abcdef123456</string>
          <hexBinary>ABCDEF123456</hexBinary>
        </hexBinary01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: hexBinary_constructor_04
       Schema: constructorSchema
         Root: hexBinary01
      Purpose: This test demonstrates the use of the xs:hexBinary constructor function and its ability to
      construct a hexBinary string from a string. In this case some characters are invalid and the test
      should result in an error.
  -->

  <tdml:parserTestCase name="hexBinary_constructor_04" root="hexBinary01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:hexBinary()  - DFDL-23-077R">

    <tdml:document>
      <tdml:documentPart type="text">abcdefj12345</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Invalid hexadecimal digit</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: byte_constructor_01
       Schema: constructorSchema
         Root: byte01
      Purpose: This test demonstrates the use of the xs:byte constructor function and its ability to
      construct a byte from a numeric string. 
  -->

  <tdml:parserTestCase name="byte_constructor_01" root="byte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:byte()  - DFDL-23-082R">

    <tdml:document>
      <tdml:documentPart type="text">15</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byte01>
          <string>15</string>
          <byte>15</byte>
        </byte01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: byte_constructor_02
       Schema: constructorSchema
         Root: byte01
      Purpose: This test demonstrates the use of the xs:byte constructor function and its ability to
      construct a byte from a numeric string. 
  -->

  <tdml:parserTestCase name="byte_constructor_02" root="byte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:byte()  - DFDL-23-082R">

    <tdml:document>
      <tdml:documentPart type="bits">00110001 00110101</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byte01>
          <string>15</string>
          <byte>15</byte>
        </byte01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: byte_constructor_03
       Schema: constructorSchema
         Root: byte01
      Purpose: This test demonstrates the use of the xs:byte constructor function and its ability to
      construct a byte from a numeric string. The range for a byte is -128 - 127 so this test should err out.
  -->

  <tdml:parserTestCase name="byte_constructor_03" root="byte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:byte()  - DFDL-23-082R">

    <tdml:document>
      <tdml:documentPart type="byte">31 32 38</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Value 128 cannot be converted to integer subtype xs:byte</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: byte_constructor_04
       Schema: constructorSchema
         Root: byte01
      Purpose: This test demonstrates the use of the xs:byte constructor function and its ability to
      construct a byte from a numeric string. The range for a byte is -128 - 127.
  -->

  <tdml:parserTestCase name="byte_constructor_04" root="byte01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:byte()  - DFDL-23-082R">

    <tdml:document>
      <tdml:documentPart type="byte">31 32 37</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <byte01>
          <string>127</string>
          <byte>127</byte>
        </byte01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: nonNeg_constructor_01
       Schema: constructorSchema
         Root: nonNeg01
      Purpose: This test demonstrates the use of the xs:nonNegativeInteger constructor function and its ability to
      construct a nonNegativeInteger from a numeric string.
  -->

  <tdml:parserTestCase name="nonNeg_constructor_01" root="nonNeg01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:nonNegativeInteger()  - DFDL-23-083R">

    <tdml:document>
      <tdml:documentPart type="text">-50,30</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Value -20 cannot be converted to integer subtype xs:nonNegativeInteger</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: nonNeg_constructor_02
       Schema: constructorSchema
         Root: nonNeg01
      Purpose: This test demonstrates the use of the xs:nonNegativeInteger constructor function and its ability to
      construct a nonNegativeInteger from a numeric string.
  -->

  <tdml:parserTestCase name="nonNeg_constructor_02" root="nonNeg01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:nonNegativeInteger()  - DFDL-23-083R">

    <tdml:document>
      <tdml:documentPart type="text">-50,60</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNeg01>
          <string>-50</string>
          <string2>60</string2>
          <nonNeg>10</nonNeg>
        </nonNeg01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: nonNeg_constructor_03
       Schema: constructorSchema
         Root: nonNeg01
      Purpose: This test demonstrates the use of the xs:nonNegativeInteger constructor function and its ability to
      construct a nonNegativeInteger from a numeric string.
  -->

  <tdml:parserTestCase name="nonNeg_constructor_03" root="nonNeg01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:nonNegativeInteger()  - DFDL-23-083R">

    <tdml:document>
      <tdml:documentPart type="text">-50,700</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nonNeg01>
          <string>-50</string>
          <string2>700</string2>
          <nonNeg>650</nonNeg>
        </nonNeg01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: nonNeg_constructor_04
       Schema: constructorSchema
         Root: nonNeg02
      Purpose: This test demonstrates the use of the xs:nonNegativeInteger constructor function and its ability to
      construct a nonNegativeInteger from a numeric string.
  -->

  <tdml:parserTestCase name="nonNeg_constructor_04" root="nonNeg02" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:nonNegativeInteger()  - DFDL-23-083R">

    <tdml:document>
      <tdml:documentPart type="text">abc</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Cannot convert string "abc" to an integer</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: uint_constructor_01
       Schema: constructorSchema
         Root: uint01
      Purpose: This test demonstrates the use of the xs:unsignedInt constructor function and its ability to
      construct an unsigned Int from a numeric string.
  -->

  <tdml:parserTestCase name="uint_constructor_01" root="uint01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedInt()  - DFDL-23-085R">

    <tdml:document>
      <tdml:documentPart type="text">-50</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Value -50 cannot be converted to integer subtype xs:unsignedInt</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: uint_constructor_02
       Schema: constructorSchema
         Root: uint01
      Purpose: This test demonstrates the use of the xs:unsignedInt constructor function and its ability to
      construct an unsigned Int from a numeric string. The range for unsignedInt is 0 - 4,294,967,295,
      so this test should cause an error.
  -->

  <tdml:parserTestCase name="uint_constructor_02" root="uint01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedInt()  - DFDL-23-085R">

    <tdml:document>
      <tdml:documentPart type="text">4294967296</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Value 4294967296 cannot be converted to integer subtype xs:unsignedInt</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: uint_constructor_03
       Schema: constructorSchema
         Root: uint01
      Purpose: This test demonstrates the use of the xs:unsignedInt constructor function and its ability to
      construct an unsigned Int from a numeric string. The range for unsignedInt is 0 - 4,294,967,295,
      so this test should cause an error.
  -->

  <tdml:parserTestCase name="uint_constructor_03" root="uint01" model="constructorSchema"
    description="Section 23 - Constructor Functions - xs:unsignedInt()  - DFDL-23-085R">

    <tdml:document>
      <tdml:documentPart type="text">4294967295</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <uint01>
          <string>4294967295</string>
          <uintified>4294967295</uintified>
        </uint01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

</tdml:testSuite>
