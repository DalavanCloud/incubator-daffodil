<?xml version="1.0" encoding="UTF-8"?>
<testSuite suiteName="Namespaces"
  xmlns="http://www.ibm.com/xmlns/dfdl/testData" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:dfdl="http://www.ogf.org/dfdl/dfdl-1.0/" xmlns:ct="http://w3.ibm.com/xmlns/dfdl/ctInfoset" xmlns:tdml="http://www.ibm.com/xmlns/dfdl/testData">

  <tdml:parserTestCase name="Lesson2_no_namespace" root="address"
    model="address_no_namespace.dfdl.xsd" description="dfdl namespace - DFDL-6-002R">
    <tdml:document><![CDATA[118*Ridgewood Circle*Rochester*NY]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <address> 
          <houseNumber>118</houseNumber>
          <street>Ridgewood Circle</street>
          <city>Rochester</city>
          <state>NY</state>
          </address>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: Lesson2_include_schema
       Schema: customer_no_namespace.dfdl.xsd
         Root: customer
      Purpose: This test demonstrates the use of xs:include to include external schemas. In this case an element in the customer
               sequence is a reference to the "address" element in the external schema.
  -->
 
  <tdml:parserTestCase name="Lesson2_include_schema" root="customer"
    model="customer_no_namespace.dfdl.xsd" description="include a schema - DFDL-6-007R">
    <tdml:document><![CDATA[James*River*118*Ridgewood Circle*Rochester*NY]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <customer>
          <firstName>James</firstName>
          <surname>River</surname>
          <address> 
            <houseNumber>118</houseNumber>
            <street>Ridgewood Circle</street>
            <city>Rochester</city>
            <state>NY</state>
          </address>
        </customer>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: Lesson2_import_schema
       Schema: customer_namespace.dfdl.xsd
         Root: customer
      Purpose: This test demonstrates the use of xs:import to include external schemas. In this case an element in the customer
               sequence is a reference to the "address" element in the external schema.
  -->
  
  <tdml:parserTestCase name="Lesson2_import_schema" root="customer"
    model="customer_namespace.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[James*River*118*Ridgewood Circle*Rochester*NY]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <customer>
          <firstName>James</firstName>
          <surname>River</surname>
          <address> 
            <houseNumber>118</houseNumber>
            <street>Ridgewood Circle</street>
            <city>Rochester</city>
            <state>NY</state>
          </address>
        </customer>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: multifile_cyclical
       Schema: cycle_base.dfdl.xsd
         Root: elem
      Purpose: This test demonstrates the use of xs:import to create an infinite loop. The loop should be caught
               and an error should be thrown.
  -->
  
  <tdml:parserTestCase name="multifile_cyclical" root="elem"
    model="cycle_base.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[1234]]></tdml:document>
    <tdml:errors>
      <tdml:error/>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: multifile_choice_01
       Schema: multi_base_01.dfdl.xsd
         Root: choice01
      Purpose: This test demonstrates the creation of a choice whose elements exist in multiple schemas.
               In this case none of the choice elements are applicable and parsing fails.
  -->
  
  <tdml:parserTestCase name="multifile_choice_01" root="choice01"
    model="multi_base_01.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[local05:123]]></tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error: Alternative failed</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: multifile_choice_02
       Schema: multi_base_01.dfdl.xsd
         Root: choice01
      Purpose: This test demonstrates the creation of a choice whose elements exist in multiple schemas.
  -->
  
  <tdml:parserTestCase name="multifile_choice_02" root="choice01"
    model="multi_base_01.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[remote01:123]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <choice01>
          <remote01>123</remote01>
        </choice01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: multifile_choice_02b
       Schema: multi_base_01.dfdl.xsd
         Root: choice01
      Purpose: This test demonstrates the creation of a choice whose elements exist in multiple schemas.
  -->
  
  <tdml:parserTestCase name="multifile_choice_02b" root="choice01"
    model="multi_base_01.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[remote01:123]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: multifile_choice_03
       Schema: multi_base_01.dfdl.xsd
         Root: choice01
      Purpose: This test demonstrates the creation of a choice whose elements exist in multiple schemas. In this case the
               appropriate element is actually a type in schema A01 based on a simpleType defined in B01, and the choice 
               itself is in base01.
  -->
  
  <tdml:parserTestCase name="multifile_choice_03" root="choice01"
    model="multi_base_01.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[remote03:5555]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <choice01>
          <remote03>5555</remote03>
        </choice01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: multifile_facets_01
       Schema: multi_base_01.dfdl.xsd
         Root: facets01
      Purpose: This test demonstrates the use of an element whose facet restrictions exist across multiple schemas.
  -->
  
  <tdml:parserTestCase name="multifile_facets_01" root="facets01"
    model="multi_base_01.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[10]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <facets01>10</facets01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: multifile_facets_02
       Schema: multi_base_01.dfdl.xsd
         Root: facets01
      Purpose: This test demonstrates the use of an element whose facet restrictions exist across multiple schemas.
  -->
  
  <tdml:parserTestCase name="multifile_facets_02" root="facets01"
    model="multi_base_01.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[11]]></tdml:document>
      <tdml:errors>
        <tdml:error>Assertion</tdml:error>
        <tdml:error>failed</tdml:error>
        <tdml:error>dfdl:checkConstraints</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: multifile_facets_03
       Schema: multi_base_01.dfdl.xsd
         Root: facets02
      Purpose: This test demonstrates the use of an element whose facet restrictions exist across multiple schemas.
  -->
  
  <tdml:parserTestCase name="multifile_facets_03" root="facets02"
    model="multi_base_01.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[10]]></tdml:document>
      <tdml:errors>
        <tdml:error>Schema Definition Error</tdml:error>
        <tdml:error>MinExclusive(11) must be less than or equal to MaxInclusive(10)</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: multifile_facets_04
       Schema: multi_base_01.dfdl.xsd
         Root: facets03
      Purpose: This test demonstrates the use of an element whose facet restrictions exist across multiple schemas.
               In this case both the maxInclusive and maxExclusive facets are defined, so the test should fail.
  -->
  
  <tdml:parserTestCase name="multifile_facets_04" root="facets03"
    model="multi_base_01.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[10]]></tdml:document>
      <tdml:errors>
        <tdml:error>Schema Definition Error</tdml:error>
        <tdml:error>MaxInclusive and MaxExclusive cannot be specified for the same simple type</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: multifile_facets_05
       Schema: multi_B_08.dfdl.xsd
         Root: bElem
      Purpose: This test demonstrates the use of an element whose facet restrictions exist across multiple schemas.
               In this case the data does not adhere to the pattern used in the assertion and the test should fail.
  -->
  
  <tdml:parserTestCase name="multifile_facets_05" root="bElem"
    model="multi_B_08.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[noooooooo]]></tdml:document>
      <tdml:errors>
        <tdml:error>Assertion failed for dfdl:checkConstraints(.)</tdml:error>
      </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: double_nesting_01
       Schema: multi_base_02.dfdl.xsd
         Root: super_seq
      Purpose: This test demonstrates that a schema with no namespace can be included in multiple namespaces
               and its elements can therefore be represented with different namespaces.
  -->
  
  <tdml:parserTestCase name="double_nesting_01" root="super_seq"
    model="multi_base_02.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[1.3.2.5|5:4:3:1]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <super_seq>
          <seq>
            <inty>1</inty>
            <inty>3</inty>
            <inty>2</inty>
            <inty>5</inty>
          </seq>
          <seq>
            <inty>5</inty>
            <inty>4</inty>
            <inty>3</inty>
            <inty>1</inty>
          </seq>
        </super_seq>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: scope_01
       Schema: multi_A_02.dfdl.xsd
         Root: seq2
      Purpose: This test demonstrates that an element used locally within the schema will take on the properties of that schema.
  -->
  
  <tdml:parserTestCase name="scope_01" root="seq2"
    model="multi_A_02.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[3.4.2.1.44.643.3.5.1]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <seq2>
          <inty>3</inty>
          <inty>4</inty>
          <inty>2</inty>
          <inty>1</inty>
          <inty>44</inty>
          <inty>643</inty>
          <inty>3</inty>
          <inty>5</inty>
          <inty>1</inty>
        </seq2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: scope_02
       Schema: multi_base_02.dfdl.xsd
         Root: super_seq2
      Purpose: This test demonstrates that an element used locally within the schema will take on the properties of that schema, 
               even if the element is defined in another schema with different properties.
  -->
  
  <tdml:parserTestCase name="scope_02" root="super_seq2"
    model="multi_base_02.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[3'6'44'22'44'2'1'63'1]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <super_seq2>
          <inty>3</inty>
          <inty>6</inty>
          <inty>44</inty>
          <inty>22</inty>
          <inty>44</inty>
          <inty>2</inty>
          <inty>1</inty>
          <inty>63</inty>
          <inty>1</inty>
        </super_seq2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_chain_01
       Schema: multi_base_03.dfdl.xsd
         Root: rabbitHole
      Purpose: This test demonstrates a long chain of declarations that gradually builds an element.
               In Schema F, a format is defined.
               In Schema E, a simpleType is declared that references the format in D.
               In Schema D, a simpleType is declared that uses the simpleType in E as a restriction base.
               In Schema C, a simpleType is declared that uses the simpleType in D as a restriction base.
               In Schema B, an element is declared of the simpleType in C.
               In Schema A, a sequence of B elements is declared
               In Base Schema, a sequence of A sequences is declared.
  -->
  
  <tdml:parserTestCase name="long_chain_01" root="rabbitHole"
    model="multi_base_03.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[f:....53....(e)|f:..41..(e)]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <rabbitHole>
          <nestSequence>
            <nest>53</nest>
            <nest>41</nest>
          </nestSequence>
        </rabbitHole>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_chain_02
       Schema: multi_base_03.dfdl.xsd
         Root: rabbitHole2
      Purpose: This test demonstrates a long chain of declarations that gradually builds an element.
                - In Schema F, a format is defined.
                - In Schema E, a simpleType is declared that references the format in D.
                - In Schema D, a simpleType is declared that uses the simpleType in E as a restriction base.
                - In Schema C, a simpleType is declared that uses the simpleType in D as a restriction base.
                - In Schema B, an element is declared of the simpleType in C.
                - In Schema A, a sequence of B elements is declared
                - In Base Schema, a sequence of A sequences is declared.
               In this case, there are overlapping properties across files, and the error should be caught.

  -->
  
  <tdml:parserTestCase name="long_chain_02" root="rabbitHole2"
    model="multi_base_03.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[f:....53....(e)|f:..41..(e)]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Overlapping properties</tdml:error>
      <tdml:error>textNumberPadCharacter overlaps between element.nest2 and simpleType.nestType.</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_chain_03
       Schema: multi_base_03.dfdl.xsd
         Root: rabbitHole3
      Purpose: This test demonstrates a long chain of declarations that gradually builds an element.
                - In Schema F, a format is defined.
                - In Schema E, a simpleType is declared that references the format in D.
                - In Schema D, a simpleType is declared that uses the simpleType in E as a restriction base.
                - In Schema C, a simpleType is declared that uses the simpleType in D as a restriction base.
                - In Schema B, an element is declared of the simpleType in C.
                - In Schema A, a sequence of B elements is declared
                - In Base Schema, a sequence of A sequences is declared.
               In this case, length is set to "4" by the global format in Schema C when nestType2 is defined, but lengthKind
               isn't set until Schema A, where it is done locally on the reference to element B.

  -->
  
  <tdml:parserTestCase name="long_chain_03" root="rabbitHole3"
    model="multi_base_03.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[5632]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <rabbitHole3>
          <nestSequence3>
            <nest3>5632</nest3>
          </nestSequence3>
        </rabbitHole3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_chain_04
       Schema: multi_base_03.dfdl.xsd
         Root: rabbitHole4
      Purpose: This test demonstrates a long chain of declarations that gradually builds an element.
                - In Schema F, a format is defined.
                - In Schema E, a simpleType is declared that references the format in D.
                - In Schema D, a simpleType is declared that uses the simpleType in E as a restriction base.
                - In Schema C, a simpleType is declared that uses the simpleType in D as a restriction base.
                - In Schema B, an element is declared of the simpleType in C.
                - In Schema A, a sequence of B elements is declared
                - In Base Schema, a sequence of A sequences is declared.
               In this case, length is set to "10" on the initial local format definition. Becuase of how scoping works, the
               length is NOT changed to "4" by the global format in Schema C.

  -->
  
  <tdml:parserTestCase name="long_chain_04" root="rabbitHole4"
    model="multi_base_03.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[5632]]></tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Insufficient Bits</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_chain_05
       Schema: multi_base_03.dfdl.xsd
         Root: rabbitHole5
      Purpose: This test demonstrates a long chain of declarations that gradually builds an element.
                - In Schema F, a format is defined.
                - In Schema E, a simpleType is declared that references the format in D.
                - In Schema D, a simpleType is declared that uses the simpleType in E as a restriction base.
                - In Schema C, a simpleType is declared that uses the simpleType in D as a restriction base.
                - In Schema B, an element is declared of the simpleType in C.
                - In Schema A, a sequence of B elements is declared
                - In Base Schema, a sequence of A sequences is declared.
               In this case, lengthKind is never set and an error should be thrown.

  -->
  
  <tdml:parserTestCase name="long_chain_05" root="rabbitHole5"
    model="multi_base_03.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[5632]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error: Property lengthKind is not defined</tdml:error>
      <tdml:error>Searched these locations</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_chain_06
       Schema: multi_A_03.dfdl.xsd
         Root: nestSequence6
      Purpose: This test demonstrates a long chain of declarations that gradually builds an element.
                - In Schema F, a format is defined.
                - In Schema E, a simpleType is declared that references the format in D.
                - In Schema D, a simpleType is declared that uses the simpleType in E as a restriction base.
                - In Schema C, a simpleType is declared that uses the simpleType in D as a restriction base.
                - In Schema B, an element is declared of the simpleType in C.
                - In Schema A, a sequence of B elements is declared
               In this case, each Schema file in the chain, starting at F, imposes its own terminator value, named
               after the schema itself (Schema E's terminator is "E", B's is "B", etc.). Each time a new schema is used
               in the chain, the separator is overwritten. Schema B is the last schema in the chain to set this value,
               so the terminator for our data set will be "B".
  -->
  
  <tdml:parserTestCase name="long_chain_06" root="nestSequence6"
    model="multi_A_03.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[5632B]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nestSequence6>
          <nest5>5632</nest5>
        </nestSequence6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_chain_06b
       Schema: multi_A_03.dfdl.xsd
         Root: nestSequence6b
      Purpose: This test demonstrates a long chain of declarations that gradually builds an element.
                - In Schema F, a format is defined.
                - In Schema E, a simpleType is declared that references the format in D.
                - In Schema D, a simpleType is declared that uses the simpleType in E as a restriction base.
                - In Schema C, a simpleType is declared that uses the simpleType in D as a restriction base.
                - In Schema B, an element is declared of the simpleType in C.
                - In Schema A, a sequence of B elements is declared
               In this case, each Schema file in the chain, starting at F, imposes its own terminator value, named
               after the schema itself (Schema E's terminator is "E", B's is "B", etc.). However, in Schema C, a terminator
               is defined on the simpleType itself, which takes precedence over global property definitions. Therefore, the
               terminator will be "C!".
  -->
  
  <tdml:parserTestCase name="long_chain_06b" root="nestSequence6b"
    model="multi_A_03.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[5632C!]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nestSequence6b>
          <nest5b>5632</nest5b>
        </nestSequence6b>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: long_chain_07
       Schema: multi_A_03.dfdl.xsd
         Root: nestSequence7
      Purpose: This test demonstrates a long chain of declarations that gradually builds an element.
                - In Schema F, a format is defined.
                - In Schema A, a sequence of B elements that reference format F is declared
               This is a test to see if I can access items in Schema F directly from Schema A because of the 
               chain of imports.
  -->
  
  <tdml:parserTestCase name="long_chain_07" root="nestSequence7"
    model="multi_A_03.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[345432F!]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <nestSequence7>
          <elem>345432</elem>
        </nestSequence7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: namespace_conflict_01
       Schema: multi_base_04.dfdl.xsd
         Root: aSeq
      Purpose: This test demonstrates a chain of declarations that gradually builds an element.
                - In Schema C, a simpleType is declared and an element defined of that type.
                - In Schema B, a sequence of 3 C elements is declared
                - In Base Schema, a sequence of sequence B is declared
               This is a test to see how having the same prefix set to multiple URIs across schemas is handled.
  -->
  
  <tdml:parserTestCase name="namespace_conflict_01" root="aSeq"
    model="multi_base_04.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[12345.123456.323|13222.764536.400]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <aSeq>
          <bSeq>
            <cElem>12345</cElem>
            <cElem>123456</cElem>
            <cElem>323</cElem>
          </bSeq>
          <bSeq>
            <cElem>13222</cElem>
            <cElem>764536</cElem>
            <cElem>400</cElem>
          </bSeq>
        </aSeq>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: no_namespace_01
       Schema: multi_base_05_nons.dfdl.xsd
         Root: baseSeq
      Purpose: This test demonstrates a chain of declarations that gradually builds an element.
                - In Schema C, a string element is declared with a pattern restriction 
                - In Schema B, a comma-separated sequence of C elements is declared
                - In Base Schema, a pipe-separated sequence of B sequences is declared
               This is a test to demonstrate how inheritance works when no namespaces are defined.
  -->
  
  <tdml:parserTestCase name="no_namespace_01" root="baseSeq"
    model="multi_base_05_nons.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[333,421,234|123,123,123,123]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <baseSeq>
          <bSeq>
            <cElem>333</cElem>
            <cElem>421</cElem>
            <cElem>234</cElem>
          </bSeq>
          <bSeq>
            <cElem>123</cElem>
            <cElem>123</cElem>
            <cElem>123</cElem>
            <cElem>123</cElem>
          </bSeq>
        </baseSeq>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: no_namespace_02
       Schema: multi_base_05_nons.dfdl.xsd
         Root: vagueBase
      Purpose: This is a test to demonstrate how the parser handles duplicate element names across
               schemas with no namespaces
  -->
  
  <tdml:parserTestCase name="no_namespace_02" root="vagueBase"
    model="multi_base_05_nons.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[333]]></tdml:document>
    <tdml:errors>
      <tdml:error>Placeholder</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: no_namespace_03
       Schema: multi_base_05_nons.dfdl.xsd
         Root: baseSeq2
      Purpose: This is a test to demonstrate how the parser handles referencing formats across
               schemas with no namespaces
  -->
  
  <tdml:parserTestCase name="no_namespace_03" root="baseSeq2"
    model="multi_base_05_nons.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[||333|||.||343|||]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>More than one definition for name: pipes</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: no_namespace_temp
       Schema: multi_temp.dfdl.xsd
         Root: baseSeq2
      Purpose: This is a test to demonstrate the error case seen in DFDL-545
  -->
  
  <tdml:parserTestCase name="no_namespace_temp" root="baseSeq2"
    model="multi_temp.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[||333|||.||343|||]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>          
      <tdml:error>leadingSkip</tdml:error>    
      <tdml:error>initiator</tdml:error>
      <tdml:error>separator</tdml:error>
      <tdml:error>terminator</tdml:error>
      <tdml:error>defineFormat</tdml:error>
      <tdml:error>format</tdml:error>      
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: no_namespace_04
       Schema: multi_base_05_nons.dfdl.xsd
         Root: baseSeq2b
      Purpose: This is a test to demonstrate how the parser handles referencing formats across
               schemas with no namespaces, when there is a name conflict between formats in separate
               files.
  -->
  
  <tdml:parserTestCase name="no_namespace_04" root="baseSeq2b"
    model="multi_base_05_nons.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[||333|||.||343|||]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <baseSeq2b>
          <elem>333</elem>
          <elem>343</elem>
        </baseSeq2b>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
    Test name: combinations_01
       Schema: multi_base_06.dfdl.xsd
         Root: baseSeq
      Purpose: This schema setup demonstrates a combination of various mult-file schema setup configurations
                Schema C defines 3 formats and does not contain a namespace. It also lives within a subfolder of the primary test folder.
                Schema B includes Schema C and has a namespace. It defines 3 date elements that each reference a different format in Schema C.
                Schema A defines a sequence group and does not have a targetNamespace. One of the group's elements is an element from Schema C.
                Base Schema includes Schema A and imports Schema B. It defines several sequence of the hidden group from Schema A, and each has
                  a different date element from Schema B.
               In this test, calendarTimeZone is not set in the format used, and the error should convey which schema components were checked for this property. 
  -->
  
  <tdml:parserTestCase name="combinations_01" root="baseSeq"
    model="multi_base_06.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[these.hidden.objs.1234.()()()()().abc.done|03-24-1988]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error: Property calendarTimeZone is not defined</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: combinations_02
       Schema: multi_base_06.dfdl.xsd
         Root: baseSeq2
      Purpose: This schema setup demonstrates a combination of various multi-file schema setup configurations
                Schema C defines 3 formats and does not contain a namespace. It also lives within a subfolder of the primary test folder.
                Schema B includes Schema C and has a namespace. It defines 3 date elements that each reference a different format in Schema C.
                Schema A defines a sequence group and does not have a targetNamespace. One of the group's elements is an element from Schema C.
                Base Schema includes Schema A and imports Schema B. It defines several sequence of the hidden group from Schema A, and each has
                  a different date element from Schema B.
               In this test, calendarTimeZone has an invalid value, and the error should point to the file where this is an issue.
  -->
  
  <tdml:parserTestCase name="combinations_02" root="baseSeq2"
    model="multi_base_06.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[these.hidden.objs.1234.()()()()().abc.done|03-24-1988]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unknown timezone specified for dfdl:calendarTimeZone</tdml:error>
      <tdml:error>Location in file:</tdml:error>
      <tdml:error>daffodil/section06/namespaces/subfolder/multi_C_06.dfdl.xsd</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: combinations_03
       Schema: multi_base_06.dfdl.xsd
         Root: baseSeq3
      Purpose: This schema setup demonstrates a combination of various multi-file schema setup configurations
                Schema C defines 3 formats and does not contain a namespace. It also lives within a subfolder of the primary test folder.
                Schema B includes Schema C and has a namespace. It defines 3 date elements that each reference a different format in Schema C.
                Schema A defines a sequence group and does not have a targetNamespace. One of the group's elements is an element from Schema C.
                Base Schema includes Schema A and imports Schema B. It defines several sequence of the hidden group from Schema A, and each has
                  a different date element from Schema B.
               In this test, everything is set up correctly and the data should be parsed without error.
  -->
  
  <tdml:parserTestCase name="combinations_03" root="baseSeq3"
    model="multi_base_06.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[these.hidden.objs.1234.()()()()().abc.c:done|03-24-1988]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <baseSeq3>
          <date3>1988-03-24</date3>
        </baseSeq3> 
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: combinations_04
       Schema: multi_base_06.dfdl.xsd
         Root: baseSeq4
      Purpose: This schema setup demonstrates a combination of various multi-file schema setup configurations
                Schema C defines a string element with an initiator. It also lives within a subfolder of the primary test folder.
                Schema B includes Schema C and has a targetNamespace.
                Schema A includes Schema C and does not have a targetNamespace
                Base Schema includes Schema A and imports Schema B. It defines a sequence of two elements that each reference the 
                  element in Schema C. One is referenced through Schema B and uses the namespace of B. The other references it through
                  Schema A, and uses the base namespace since A has none. Each element is then modified with a unique terminator.
               In this test, everything is set up correctly and the data should be parsed without error.
  -->
  
  <tdml:parserTestCase name="combinations_04" root="baseSeq4"
    model="multi_base_06.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[c:one{|c:two}]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <baseSeq4>
          <cElem>one</cElem>
          <cElem>two</cElem>
        </baseSeq4> 
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: negative_import_01
       Schema: multi_base_07_failure.dfdl.xsd
         Root: elem
      Purpose: In this test the schema attempts to import a namespace that does not exist and should fail accordingly.
  -->
  
  <tdml:parserTestCase name="negative_import_01" root="elem"
    model="multi_base_07_failure.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[1]]></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Import element specifies namespace http://b00.com but namespace http://b06.com of imported schema does not match</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: multi_encoding_01
       Schema: multi_base_09.dfdl.xsd
         Root: base
      Purpose: In this test the two schemas used are in different encodings - base Schema is utf-16be, while
               Schema A is utf-8. This should not interfere with the test and it should pass without issue.
  -->
  
  <tdml:parserTestCase name="multi_encoding_01" root="base"
    model="multi_base_09.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[A:one:A,55]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <base>
          <aElem>one</aElem>
          <baseElem>55</baseElem>
        </base>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: multi_encoding_02
       Schema: multi_base_09.dfdl.xsd
         Root: base2
      Purpose: In this test the two schemas used are in different encodings - base Schema is utf-16be, while
               Schema A is utf-8. The sequence referenced has two elements, the first is a utf-8 binary string,
               the second is a utf-16be binary string initiated by "A:" and terminated by ":A",
               and they are separated by a us-ascii comma.
  -->
  
  <tdml:parserTestCase name="multi_encoding_02" root="base2"
    model="multi_base_09.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document>
      <tdml:documentPart type="byte">35 35</tdml:documentPart>  <!-- UTF-8 for "55" -->
      <tdml:documentPart type="byte">2C</tdml:documentPart>     <!-- US-ASCII for "," -->
      <tdml:documentPart type="byte">00 41 00 3A 00 6F 00 6E 00 65 00 3A 00 41</tdml:documentPart> <!-- UTF-16BE for "A:one:A" -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <base2>
          <baseElem>55</baseElem>
          <aElem2>one</aElem2>
        </base2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: multi_encoding_03
       Schema: multi_base_09.dfdl.xsd
         Root: base3
      Purpose: In this test the two schemas used are in different encodings - base Schema is utf-16be, while
               Schema A is utf-8. The sequence referenced has two explicit-length binary string, the first
               is utf-8 and the second if utf-16be. It should be parsed correctly.
  -->
  
  <tdml:parserTestCase name="multi_encoding_03" root="base3"
    model="multi_base_09.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document>
      <tdml:documentPart type="byte">35 35</tdml:documentPart>              <!-- UTF-8 for "55" -->
      <tdml:documentPart type="byte">00 6F 00 6E 00 65</tdml:documentPart>  <!-- UTF-16BE for "one" -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <base3>
          <baseElem>55</baseElem>
          <aElem3>one</aElem3>
        </base3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: multi_encoding_04
       Schema: multi_base_09.dfdl.xsd
         Root: base4
      Purpose: In this test the two schemas used are in different encodings - base Schema is utf-16be, while
               Schema A is utf-8. The sequence contains two elements whose lengths are delimited, with no delimiters defined.
               Each element is in a different encoding.
  -->
  
  <tdml:parserTestCase name="multi_encoding_04" root="base4"
    model="multi_base_09.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document>
      <tdml:documentPart type="byte">35 35</tdml:documentPart>              <!-- UTF-8 for "55" -->
      <tdml:documentPart type="byte">00 6F 00 6E 00 65</tdml:documentPart>  <!-- UTF-16BE for "one" -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <base4>
          <baseElem>55</baseElem>
          <baseElem2>one</baseElem2>
        </base4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="import_format_01"
    description="Imported Schema Format - Use imported schema's default format"
    model="predefined_format.dfdl.xsd" root="seq_01">
    <tdml:document>
      <tdml:documentPart type="text">1,2,3</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <seq_01>
          <e1>1</e1>
          <e2>2</e2>
          <e3>3</e3>
        </seq_01>
      </tdml:dfdlInfoset>

    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="import_format_02"
    description="Imported Schema Format - Use default format except for overridden values"
    model="predefined_format.dfdl.xsd" root="seq_02">
    <tdml:document>
      <tdml:documentPart type="text">98% 53% 100%</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <seq_02>
          <e1>98</e1>
          <e2>53</e2>
          <e3>100</e3>
        </seq_02>
      </tdml:dfdlInfoset>

    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: element_conflict_01
       Schema: multi_base_10.dfdl.xsd
         Root: root
      Purpose: Schema B does not have a namespace and defines an element "foo"
               Schema A does have a namespace and also defines an element "foo"
               In Base Schema, a comma-separated sequence of Schema A foo element and Schema B foo element is declared.
               This is a test to demonstrate how name clashes are handled.
  -->
  
  <tdml:parserTestCase name="element_conflict_01" root="root"
    model="multi_base_10.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[foo1,foo2]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <root>
          <foo>foo1</foo>
          <foo>foo2</foo>
        </root>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: element_conflict_02
       Schema: multi_base_10.dfdl.xsd
         Root: root2
      Purpose: Schema C does have a namespace and defines an element "foo"
               Schema A does have a namespace and also defines an element "foo"
               In Base Schema, a comma-separated sequence of Schema A foo element and Schema C foo element is declared.
               This is a test to demonstrate how name clashes are handled.
  -->
  
  <tdml:parserTestCase name="element_conflict_02" root="root2"
    model="multi_base_10.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[c:foo1,foo2]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <root2>
          <foo>foo1</foo>
          <foo>foo2</foo>
        </root2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: lion_eater_ambiguity_01
       Schema: multi_base_shi.dfdl.xsd
         Root: shishishi
      Purpose: This test demonstrates a basic one-schema scenario, where all user-defined values are "shi"
               or some variation of "shi", including initiators, terminators, separators, namespaces, 
               element names, etc. These should not be confused and the data should parse without issue.
  -->
  
  <tdml:parserTestCase name="lion_eater_ambiguity_01" root="shishishi"
    model="multi_base_shi.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document>
      <tdml:documentPart type="text">shi</tdml:documentPart> <!-- root element shishishi initiator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi value -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence separator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi value -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence terminator -->
      <tdml:documentPart type="text">shi</tdml:documentPart> <!-- root element shishishi terminator -->
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <shishishi>
          <shi>shi</shi>
          <shi>shi</shi>
        </shishishi>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: lion_eater_ambiguity_01b
       Schema: multi_base_shi.dfdl.xsd
         Root: shishishi2
      Purpose: This test verifies that using "shi:shi:string" as a type no longer causes a "should be no fall through to this case"
               abort message.
  -->
  
  <tdml:parserTestCase name="lion_eater_ambiguity_01b" root="shishishi2"
    model="multi_base_shi2.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document>
      <tdml:documentPart type="text">shi</tdml:documentPart> <!-- root element shishishi initiator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi value -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence separator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi value -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence terminator -->
      <tdml:documentPart type="text">shi</tdml:documentPart> <!-- root element shishishi terminator -->
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Error loading schema</tdml:error>
      <tdml:error>'shi:shi:string' is not a valid value for 'QName'</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: lion_eater_ambiguity_02
       Schema: multi_base_shi.dfdl.xsd
         Root: shishishishi
      Purpose: This test demonstrates a multi-schema scenario, where all user-defined values are "shi"
               or some variation of "shi", including initiators, terminators, separators, namespaces, 
               element names, etc. These should not be confused and the data should parse without issue.
  -->
  
  <tdml:parserTestCase name="lion_eater_ambiguity_02" root="shishishishi"
    model="multi_base_shi.dfdl.xsd" description="import a schema - DFDL-6-007R">

    <tdml:document>
      <tdml:documentPart type="text">shi</tdml:documentPart> <!-- root element shishishishi initiator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishi:shishi initiator -->
            <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence initiator -->
              <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishi:shi initiator -->
              <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishi:shi value -->
              <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishi:shi terminator -->
            <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence separator -->
              <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishi:shi initiator -->
              <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishi:shi value -->
              <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishi:shi terminator -->
            <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence terminator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishi:shishi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence separator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi value -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence terminator -->
      <tdml:documentPart type="text">shi</tdml:documentPart> <!-- root element shishishishi terminator -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <shishishishi>
          <shiShishi>
            <shi>shi</shi>
            <shi>shi</shi>
          </shiShishi>
          <shi>shi</shi>
        </shishishishi>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: lion_eater_ambiguity_03
       Schema: multi_base_shi.dfdl.xsd
         Root: shishishishishi
      Purpose: This test demonstrates a multi-schema scenario, where all user-defined values are "shi"
               or some variation of "shi", including initiators, terminators, separators, namespaces, 
               element names, etc. These should not be confused and the data should parse without issue.
  -->
  
  <tdml:parserTestCase name="lion_eater_ambiguity_03" root="shishishishishi"
    model="multi_base_shi.dfdl.xsd" description="import a schema - DFDL-6-007R">

    <tdml:document>
      <tdml:documentPart type="text">shi</tdml:documentPart> <!-- root element shishishishi initiator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi value -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence separator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi value -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence separator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi value -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence terminator -->
      <tdml:documentPart type="text">shi</tdml:documentPart> <!-- root element shishishishi terminator -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <shishishishishi>
          <shi>shi</shi>
          <shi>shi</shi>
          <shi>shi</shi>
        </shishishishishi>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
    Test name: lion_eater_ambiguity_04
       Schema: multi_base_shi.dfdl.xsd
         Root: shi2
      Purpose: This test demonstrates a multi-schema scenario, where all user-defined values are "shi"
               It results in a schema definition error, which should clearly point to the location of the
               issue.
  -->
  
  <tdml:parserTestCase name="lion_eater_ambiguity_04" root="shi2"
  model="multi_base_shi.dfdl.xsd" description="import a schema - DFDL-6-007R">

    <tdml:document>shishishi122shishishi</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>MinInclusive(16) must be less than or equal to MaxInclusive(10)</tdml:error>
      <tdml:error>shishi</tdml:error>
      <tdml:error>Location in file:</tdml:error>
      <tdml:error>section06/namespaces/shi</tdml:error>      
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: lion_eater_ambiguity_05
       Schema: multi_base_shi.dfdl.xsd
         Root: shi3
      Purpose: This test demonstrates a multi-schema scenario, where all user-defined values are "shi"
               or some variation of "shi", including initiators, terminators, separators, namespaces, 
               element names, etc. These should not be confused and the data should parse without issue.
  -->
  
  <tdml:parserTestCase name="lion_eater_ambiguity_05" root="shi3"
    model="multi_base_shi.dfdl.xsd" description="import a schema - DFDL-6-007R">

    <tdml:document>
      <tdml:documentPart type="text">shi</tdml:documentPart> <!-- root element shishishishi initiator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi initiator -->
          <tdml:documentPart type="text">5</tdml:documentPart> <!-- element shi value -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence separator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishishi:shi initiator -->
          <tdml:documentPart type="text">12345</tdml:documentPart> <!-- element shishishi:shi value -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishishi:shi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence separator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishi:shi initiator -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishi:shi value -->
          <tdml:documentPart type="text">shi</tdml:documentPart> <!-- element shishi:shi terminator -->
        <tdml:documentPart type="text">shi</tdml:documentPart> <!-- sequence terminator -->
      <tdml:documentPart type="text">shi</tdml:documentPart> <!-- root element shishishishi terminator -->
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <shi3>
          <shi>5</shi>
          <shi>12345</shi>
          <shi>shi</shi>
        </shi3>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>
  
  <!--
    Test name: namespace_ultra_uniqueness_01
       Schema: multi_base_11.dfdl.xsd
         Root: root
      Purpose: This test demonstrates a multi-schema scenario, where all namespace prefixes are unique.
               the information should not be confused and it should parse without issue.
  -->
  
  <tdml:parserTestCase name="namespace_ultra_uniqueness_01" root="root"
    model="multi_base_11.dfdl.xsd" description="import a schema - DFDL-6-007R">

    <tdml:document>1</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <root>1</root>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: namespace_ultra_uniqueness_02
       Schema: multi_base_11.dfdl.xsd
         Root: root2
      Purpose: This test demonstrates a multi-schema scenario, where all namespace prefixes are unique.
               the information should not be confused and it should parse without issue.
  -->
  
  <tdml:parserTestCase name="namespace_ultra_uniqueness_02" root="root2"
    model="multi_base_11.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document>03-04-2013,04-12-1997,05-22-1980</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <root2>
          <date3>2013-03-04</date3>
          <date3>1997-04-12</date3>
          <date3>1980-05-22</date3>
        </root2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: namespace_ultra_uniqueness_03
       Schema: multi_base_11.dfdl.xsd
         Root: root3
      Purpose: This test demonstrates a multi-schema scenario, where many namespace prefixes are unique.
               In this case, the data should fail to parse because an int is expected, but a string is provided.
  -->
  
  <tdml:parserTestCase name="namespace_ultra_uniqueness_03" root="root3"
    model="multi_base_11.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document>thisIsNotAnInteger</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Convert to Integer (for xs:int)</tdml:error>
      <tdml:error>Unable to parse 'thisIsNotAnInteger'</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: namespace_ultra_uniqueness_04
       Schema: multi_base_11.dfdl.xsd
         Root: root4
      Purpose: This test demonstrates a multi-schema scenario, where many namespace prefixes are unique.
               In this case, the data should fail to parse because an int is expected, but a string is provided.
  -->
  
  <tdml:parserTestCase name="namespace_ultra_uniqueness_04" root="root4"
    model="multi_base_11.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document>thisIsNotAnInteger</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>Convert to Integer (for xs:int)</tdml:error>
      <tdml:error>Unable to parse 'thisIsNotAnInteger'</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: namespace_scope_01
       Schema: multi_base_11.dfdl.xsd
         Root: root5
      Purpose: This test demonstrates a multi-schema scenario, where many namespace prefixes are unique.
               In this case, the data should fail to parse because the definition of the foo namespace prefix was overridden.
               The new namespace does not have a "stringy" type.
  -->

  <tdml:parserTestCase name="namespace_scope_01" root="root5"
    model="multi_base_11.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document>thisIsNotAnInteger</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>No type definition found for 'foo:stringy'</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
    Test name: namespace_scope_02
       Schema: multi_base_11.dfdl.xsd
         Root: root6
      Purpose: This test demonstrates a multi-schema scenario, where many namespace prefixes are unique.
               In this case, though the definition of the foo namespace prefix was overridden, the bar 
               prefix was assigned to the namespace for Schema B, so that prefix should work and this should
               parse correctly.
  -->
  
  <tdml:parserTestCase name="namespace_scope_02" root="root6"
    model="multi_base_11.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document>7</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <root6>
          <notAStringy3>7</notAStringy3>
        </root6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
    Test name: error_messages_01
       Schema: multi_base_12.dfdl.xsd
         Root: rabbitHole
      Purpose: This test demonstrates that error messages with multi-file schemas are very specific
               and help the user quickly find the issue.
  -->
  
  <tdml:parserTestCase name="error_messages_01" root="rabbitHole"
    model="multi_base_12.dfdl.xsd" description="import a schema - DFDL-6-007R">
    <tdml:document><![CDATA[f:....53....(e)|f:..41..(e)]]></tdml:document>
    <tdml:errors>
      <tdml:error>Placeholder</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

</testSuite>
