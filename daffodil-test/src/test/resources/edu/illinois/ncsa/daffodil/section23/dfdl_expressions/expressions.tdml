<?xml version="1.0" encoding="UTF-8"?>
<tdml:testSuite suiteName="expressions"
  description="lengthKind explicit and occursCountKind expression"
  xmlns:tdml="http://www.ibm.com/xmlns/dfdl/testData" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:dfdl="http://www.ogf.org/dfdl/dfdl-1.0/" xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:ex="http://example.com" 
  xmlns:daf="urn:ogf:dfdl:2013:imp:opensource.ncsa.illinois.edu:2012:ext"  
  xmlns:fn="http://www.w3.org/2005/xpath-functions">
  
  <tdml:defineSchema name="paths">
    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited"/>

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="seq" dfdl:separator=",">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="items" type="xs:string" dfdl:inputValueCalc="{ /ex:e1/ex:seq/ex:item }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="items" type="xs:string" dfdl:inputValueCalc="{ /ex:e2/ex:seq/../ex:seq/../ex:seq/ex:item[2] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="seq2">
            <xs:complexType>
              <xs:sequence dfdl:separator="|">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="seq3">
            <xs:complexType>
              <xs:sequence dfdl:separator=":">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="items" type="xs:string" dfdl:inputValueCalc="{ /ex:e3/ex:seq/ex:item[2] + /ex:e3/ex:seq/../ex:seq2/ex:item[1] + /ex:e3/ex:seq3/../ex:seq2/../ex:seq/../ex:seq3/ex:item[4] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="seq2">
            <xs:complexType>
              <xs:sequence dfdl:separator="|">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="seq3">
            <xs:complexType>
              <xs:sequence dfdl:separator=":">
                <xs:element name="item" type="xs:int" minOccurs="1" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="items" type="xs:string" dfdl:inputValueCalc="{ /ex:e4/ex:seq3/../ex:seq2/../ex:seq/ex:item/../../ex:seq3/ex:item }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="seq">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" dfdl:terminator="!" minOccurs="1" maxOccurs="10">
                  <xs:complexType>
                    <xs:sequence dfdl:separator="+">
                      <xs:element name="sub" type="xs:int" minOccurs="1" maxOccurs="2"/>
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="items" type="xs:string" dfdl:inputValueCalc="{ /ex:e5/ex:seq/ex:item/ex:sub[2] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>


  <tdml:defineSchema name="hiddenElem">
    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited"/>
    
    <xs:group name="hiddenData">
      <xs:sequence dfdl:separator="|">
        <xs:element name="password" type="xs:string" dfdl:initiator="pw:" minOccurs="0" maxOccurs="1" dfdl:lengthKind="delimited"/>
      </xs:sequence>
    </xs:group>    

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:sequence dfdl:hiddenGroupRef="ex:hiddenData"/>
          <xs:element name="hideme" type="xs:string" dfdl:inputValueCalc="{ fn:concat(fn:substring(/ex:e1/ex:password[1], 1, 1), '***') }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence>
          <xs:sequence dfdl:hiddenGroupRef="ex:hiddenData"/>
          <xs:element name="unhideme" type="xs:string" dfdl:inputValueCalc="{ /ex:e2/ex:password[1] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
  
  </tdml:defineSchema>

  <tdml:defineSchema name="asterisk">
    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited"/>

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="nest">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="children" type="xs:string" dfdl:inputValueCalc="{ /ex:e1/ex:nest/* }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="nest">
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="children" type="xs:string" dfdl:inputValueCalc="{ //* }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>
  
  <tdml:defineSchema name="attributeAxis">
    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited"/>

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:nilKind="literalValue" nillable="true" dfdl:nilValue="NIL"/>
          <xs:element name="isNil" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string@nil }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:nilKind="literalValue" nillable="true" dfdl:nilValue="NIL"/>
          <xs:element name="isNil" type="xs:boolean" dfdl:inputValueCalc="{ //@nil }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string" type="xs:string" dfdl:nilKind="literalValue" nillable="true" dfdl:nilValue="NIL"/>
          <xs:element name="isNil" type="xs:boolean" dfdl:inputValueCalc="{ //ex:string[@*] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>  

  <tdml:defineSchema name="comparisonOperators">
    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited"/>

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="same" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="same" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 = ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 lt ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 &lt; ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="float1" type="xs:float"/> 
          <xs:element name="float2" type="xs:float"/> 
          <xs:element name="oneGTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:float1 gt ../ex:float2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e6">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="float1" type="xs:float"/> 
          <xs:element name="float2" type="xs:float"/> 
          <xs:element name="oneGTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:float1 &gt; ../ex:float2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e7">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="notEqual" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 ne ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e8">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="notEqual" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 != ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e9">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="notEqual" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 ne ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e10">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="lessThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 le ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e11">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="lessThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 &lt;= ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e12">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="greaterThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 ge ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e13">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="int1" type="xs:int"/> 
          <xs:element name="int2" type="xs:int"/> 
          <xs:element name="greaterThanEqualTo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:int1 &gt;= ../ex:int2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e14">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="oneGTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 gt ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e15">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/> 
          <xs:element name="string2" type="xs:string"/> 
          <xs:element name="oneLTtwo" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 lt ../ex:string2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:defineSchema name="newRegex">
    <dfdl:format ref="ex:daffodilTest1" />
    
    <xs:simpleType name="st1">
      <xs:restriction base="xs:string">
        <xs:pattern value="\d\d(?=\D+)" />
      </xs:restriction>
    </xs:simpleType>
    
    <xs:element name="s3">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="ex:st1" dfdl:lengthKind="delimited">
            <xs:annotation>
              <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:assert test="{ dfdl:checkConstraints(.) }"
                  message="Assertion failed for dfdl:checkConstraints(.)" />
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element name="extra" type="xs:string" dfdl:lengthKind="delimited"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="s1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:string" dfdl:lengthKind="pattern" dfdl:lengthPattern="\d\d(?=\D+)"/>
          <xs:element name="extra" type="xs:string" dfdl:lengthKind="delimited"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="s2">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:int" dfdl:lengthKind="pattern" dfdl:lengthPattern="\d\d(?=\D+)">
            <xs:annotation>
              <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:assert testKind="pattern" testPattern="\d\d(?=\D+)"
                  message="Assertion failed for pattern '\d\d'" />
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
          <xs:element name="extra" type="xs:string" dfdl:lengthKind="delimited"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="s4">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:string" dfdl:lengthKind="pattern" dfdl:lengthPattern="\U0010ffff"/>
          <xs:element name="extra" type="xs:string" dfdl:lengthKind="delimited"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:defineSchema name="lke1_rel">
    <dfdl:format ref="ex:daffodilTest1" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="len" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="s1" type="xs:string"
            dfdl:lengthKind="explicit" dfdl:length="{ ../ex:len }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="lke1_rel" root="e1"
    model="lke1_rel" description="simplest computed length - DFDL-23-011R">

    <tdml:document>
      <tdml:documentPart type="byte">00000004
			</tdml:documentPart>
      <tdml:documentPart type="text">abcd</tdml:documentPart>
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:len>4</ex:len>
          <ex:s1>abcd</ex:s1>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <tdml:defineSchema name="lke1_abs">
    <dfdl:format ref="ex:daffodilTest1" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="len" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="s1" type="xs:string"
            dfdl:lengthKind="explicit" dfdl:length="{ /ex:e1/ex:len }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>


  <tdml:parserTestCase name="lke1_abs" root="e1"
    model="lke1_abs" description="simplest computed length - DFDL-23-011R">

    <tdml:document>
      <tdml:documentPart type="byte">00000004
			</tdml:documentPart>
      <tdml:documentPart type="text">abcd</tdml:documentPart>
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:len>4</ex:len>
          <ex:s1>abcd</ex:s1>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <tdml:defineSchema name="ocke1">
    <dfdl:format ref="ex:daffodilTest1" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="reps" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="scale" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="s1" type="xs:string"
            dfdl:lengthKind="explicit" dfdl:length="{1}"
            dfdl:occursCount="{ ../ex:reps * /ex:e1/ex:scale}"
            dfdl:occursCountKind="expression" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="ocke1" root="e1" model="ocke1"
    description="very simple occursCountKind expression - DFDL-23-011R">

    <tdml:document>
      <!-- two binary integers get multiplied 2x2=4 -->
      <tdml:documentPart type="byte">00000002 00000002
			</tdml:documentPart>
      <!-- followed by that many characters, each is an element of the array -->
      <tdml:documentPart type="text">abcd</tdml:documentPart>
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:reps>2</ex:reps>
          <ex:scale>2</ex:scale>
          <ex:s1>a</ex:s1>
          <ex:s1>b</ex:s1>
          <ex:s1>c</ex:s1>
          <ex:s1>d</ex:s1>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <tdml:defineSchema name="ocke2">
    <dfdl:format ref="ex:daffodilTest1" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="scale" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="hdr">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="reps" type="xs:int"
                  dfdl:representation="binary" dfdl:lengthKind="implicit" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="body">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="s1" type="xs:string"
                  dfdl:lengthKind="explicit" dfdl:length="{1}"
                  dfdl:occursCount="{ ../../ex:hdr/ex:reps * /ex:e1/ex:scale}"
                  dfdl:occursCountKind="expression" minOccurs="0"
                  maxOccurs="unbounded" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="ocke2" root="e1" model="ocke2"
    description="very simple occursCountKind expression - DFDL-23-011R">

    <tdml:document>
      <!-- two binary integers get multiplied 2x2=4 -->
      <tdml:documentPart type="byte">00000003 00000002
			</tdml:documentPart>
      <!-- followed by that many characters, each is an element of the array -->
      <tdml:documentPart type="text">abcdef</tdml:documentPart>
    </tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:scale>3</ex:scale>
          <ex:hdr>
            <ex:reps>2</ex:reps>
          </ex:hdr>
          <ex:body>
            <ex:s1>a</ex:s1>
            <ex:s1>b</ex:s1>
            <ex:s1>c</ex:s1>
            <ex:s1>d</ex:s1>
            <ex:s1>e</ex:s1>
            <ex:s1>f</ex:s1>
          </ex:body>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <tdml:defineSchema name="ArrayOptionalElem-Embedded.dfdl.xsd">

    <dfdl:format ref="ex:daffodilTest1" lengthUnits="bytes"
      encoding="UTF-8" separator="" initiator="" terminator=""
      occursCountKind="parsed" ignoreCase="no" textNumberRep="standard"
      representation="text" byteOrder="bigEndian" binaryNumberRep="binary" />

    <xs:element name="aoe_01">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="reps" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="rows" type="xs:byte"
            dfdl:representation="binary" maxOccurs="unbounded"
            dfdl:lengthKind="implicit" dfdl:occursCountKind="expression"
            dfdl:occursCount="{ ../ex:reps }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="aoe_02">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="reps" type="xs:unsignedInt"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="rows" type="xs:byte"
            dfdl:representation="binary" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:reps }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="ArrayOptElem_01" root="aoe_01"
    model="ArrayOptionalElem-Embedded.dfdl.xsd" description="occursCountKind expression with relative path - DFDL-23-011R">

    <tdml:document>
      <tdml:documentPart type="byte">00000003000102
			</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <aoe_01>
          <reps>3</reps>
          <rows>0</rows>
          <rows>1</rows>
          <rows>2</rows>
        </aoe_01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="ArrayOptElem_02" root="aoe_02"
    model="ArrayOptionalElem-Embedded.dfdl.xsd"
    description="an unsignedInt value in an occursCount expression - DFDL-23-011R">

    <tdml:document>
      <tdml:documentPart type="byte">00000003000102
			</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <aoe_02>
          <reps>3</reps>
          <rows>0</rows>
          <rows>1</rows>
          <rows>2</rows>
        </aoe_02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="expressions-Embedded.dfdl.xsd">

    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited"
      lengthUnits="bytes" encoding="US-ASCII" separator="" initiator=""
      terminator="" occursCountKind="parsed" ignoreCase="no"
      textNumberRep="standard" representation="text" />

    <xs:element name="lke_01" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="{../ex:e1}" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="lke_02" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:int" dfdl:encoding="utf-8"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:int" dfdl:encoding="utf-8"
            dfdl:lengthKind="explicit" dfdl:length="{../ex:e1}" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ocke" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:initiator="">
          <xs:element name="nrows" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="ncols" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="rows" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:nrows }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="cols" type="xs:int"
                  maxOccurs="unbounded" dfdl:lengthKind="delimited"
                  dfdl:terminator="," dfdl:occursCountKind="expression"
                  dfdl:occursCount="{ ../../ex:ncols }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ocke2" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:initiator="">
          <xs:element name="nrows" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="ncols" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="rows" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:nrows }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="cols" type="xs:int"
                  maxOccurs="unbounded" dfdl:lengthKind="delimited"
                  dfdl:terminator="," dfdl:occursCountKind="expression"
                  dfdl:occursCount="
                  { ../../ex:ncols } " />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ocke3" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:initiator="">
          <xs:element name="nrows" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="ncols" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="rows" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:nrows }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="cols" type="xs:int"
                  maxOccurs="unbounded" dfdl:lengthKind="delimited"
                  dfdl:terminator="," dfdl:occursCountKind="expression"
                  dfdl:occursCount=" { ../../ex:ncols } " />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="ocke4" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:initiator="">
          <xs:element name="nrows" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="ncols" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator="," />
          <xs:element name="rows" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:nrows }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="cols" type="xs:int"
                  maxOccurs="unbounded" dfdl:lengthKind="delimited"
                  dfdl:terminator="," dfdl:occursCountKind="expression"
                  dfdl:occursCount=" { ../../ex:ncols }
                  " />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="expr_space" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dummy" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="value" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc=" { '    a    b    ' } "  />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="expr_space2" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dummy" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="value" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc=" { 'a
b
c' } "  />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="expr_space3" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="dummy" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="value" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc=" { ' a b c ' } "  />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ws_expr" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:int" maxOccurs="unbounded"
            dfdl:lengthKind="delimited" dfdl:terminator="]%NL;=" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="ws_expr2" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:int" maxOccurs="unbounded"
            dfdl:lengthKind="delimited" dfdl:terminator="]&#xA;=" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="lke2_rel" root="lke_01"
    model="expressions-Embedded.dfdl.xsd" description="length expression, relative path - DFDL-23-011R">

    <tdml:document>3538</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <lke_01>
          <e1>3</e1>
          <e2>538</e2>
        </lke_01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="lke3_rel" root="lke_02"
    model="expressions-Embedded.dfdl.xsd" description="length expression, relative path - DFDL-23-011R">

    <tdml:document>3538</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <lke_02>
          <e1>3</e1>
          <e2>538</e2>
        </lke_02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: ocke_rel
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates the use of relative paths in an occursCount expression 
-->

  <tdml:parserTestCase name="ocke_rel" root="ocke"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2,3,1,2,3,4,5,6,]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ocke>
          <nrows>2</nrows>
          <ncols>3</ncols>
          <rows>
            <cols>1</cols>
            <cols>2</cols>
            <cols>3</cols>
          </rows>
          <rows>
            <cols>4</cols>
            <cols>5</cols>
            <cols>6</cols>
          </rows>
        </ocke>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: ocke_rel2
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that whitespace surrounding an expression is collapsed. In this case,
                there is a newline in front of the expression and a space afterwards. 
-->
  
  <tdml:parserTestCase name="ocke_rel2" root="ocke2"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2,3,1,2,3,4,5,6,]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ocke2>
          <nrows>2</nrows>
          <ncols>3</ncols>
          <rows>
            <cols>1</cols>
            <cols>2</cols>
            <cols>3</cols>
          </rows>
          <rows>
            <cols>4</cols>
            <cols>5</cols>
            <cols>6</cols>
          </rows>
        </ocke2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: ocke_rel3
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that whitespace surrounding an expression is collapsed. In this case,
                there is a space in front of the expression and a space afterwards. 
-->
  
  <tdml:parserTestCase name="ocke_rel3" root="ocke3"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2,3,1,2,3,4,5,6,]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ocke3>
          <nrows>2</nrows>
          <ncols>3</ncols>
          <rows>
            <cols>1</cols>
            <cols>2</cols>
            <cols>3</cols>
          </rows>
          <rows>
            <cols>4</cols>
            <cols>5</cols>
            <cols>6</cols>
          </rows>
        </ocke3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: ocke_rel4
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that whitespace surrounding an expression is collapsed. In this case,
                there is a space in front of the expression and a newline afterwards. 
-->
  
  <tdml:parserTestCase name="ocke_rel4" root="ocke4"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2,3,1,2,3,4,5,6,]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ocke4>
          <nrows>2</nrows>
          <ncols>3</ncols>
          <rows>
            <cols>1</cols>
            <cols>2</cols>
            <cols>3</cols>
          </rows>
          <rows>
            <cols>4</cols>
            <cols>5</cols>
            <cols>6</cols>
          </rows>
        </ocke4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: internal_space_preserved
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that whitespace surrounding an expression is collapsed, but whitespace
                within the expression is preserved.
-->
  
  <tdml:parserTestCase name="internal_space_preserved" root="expr_space"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <expr_space>
          <dummy>2</dummy>
          <value><![CDATA[    a    b    ]]></value>
        </expr_space>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: internal_space_preserved2
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that whitespace surrounding an expression is collapsed, but whitespace
                within the expression is preserved.
-->
  
  <tdml:parserTestCase name="internal_space_preserved2" root="expr_space2"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <expr_space2>
          <dummy>2</dummy>
          <value><![CDATA[a
            b                                    c]]></value>
        </expr_space2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: internal_space_preserved3a
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that the TDML runner is providing false positives because it is not taking whitespace
                into account
-->
  
  <tdml:parserTestCase name="internal_space_preserved3a" root="expr_space3"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <expr_space3>
          <dummy>2</dummy>
          <value><![CDATA[a            b                                    c]]></value>
        </expr_space3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: internal_space_preserved3b
        Schema: expressions-Embedded.dfdl.xsd
       Purpose: This test demonstrates that the TDML runner is providing false positives because it is not taking whitespace
                into account
-->
  
  <tdml:parserTestCase name="internal_space_preserved3b" root="expr_space3"
    model="expressions-Embedded.dfdl.xsd" description="occursCountKind expression - DFDL-23-011R">

    <tdml:document><![CDATA[2]]></tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <expr_space3>
          <dummy>2</dummy>
          <value><![CDATA[a     b     c]]></value>
        </expr_space3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="expression-type-errors.dfdl.xsd">

    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited"
      lengthUnits="bytes" encoding="UTF-8" separator="" initiator=""
      terminator="" occursCountKind="parsed" ignoreCase="no"
      textNumberRep="standard" representation="text" />

    <xs:element name="e" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:string"
            dfdl:inputValueCalc="{ 'S' }" />
          <xs:element name="e2" type="xs:int"
            dfdl:inputValueCalc="{ 2 }" />
          <xs:element name="e3" type="xs:int"
            dfdl:inputValueCalc="{ ../ex:e2 + ../ex:e1 }" /> <!-- type error adding string to int is n.g. -->
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="f" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e3" type="xs:int"
            dfdl:inputValueCalc="{ 2.5 }" /> <!-- type error as result is not int. -->
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="g" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:string"
            dfdl:inputValueCalc="{ 'notAnInt' }" />
          <xs:element name="e3" type="xs:int"
            dfdl:inputValueCalc="{ ../ex:e1 }" /> <!-- type error -->
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="h" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e1" type="xs:string"
            dfdl:inputValueCalc="{ 2.0 + 'cant add this' }" /><!-- compilation time type error -->
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="expression_type_error1"
    root="e" model="expression-type-errors.dfdl.xsd"
    description="get a type error from an expression at runtime - DFDL-23-006R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>+</tdml:error>
      <tdml:error>operator</tdml:error>
      <tdml:error>numeric</tdml:error>
      <tdml:error>string</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="expression_type_error2"
    root="f" model="expression-type-errors.dfdl.xsd"
    description="get a type error from an expression at compile time - DFDL-23-006R">
    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>convert</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="expression_type_error3"
    root="g" model="expression-type-errors.dfdl.xsd"
    description="get a type error from an expression at runtime - DFDL-23-006R">
    <tdml:document />
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>notAnInt</tdml:error>
      <tdml:error>String</tdml:error>
      <tdml:error>Long</tdml:error>
    </tdml:errors>
    <!-- <tdml:infoset> <tdml:dfdlInfoset xmlns="http://example.com"> <g>
      <e1>notAnInt</e1>
      <e3>2</e3> </g> </tdml:dfdlInfoset> </tdml:infoset> -->
  </tdml:parserTestCase>
  
  <tdml:parserTestCase name="expression_type_error4"
    root="h" model="expression-type-errors.dfdl.xsd"
    description="get a type error from an expression at compilation time - specific requirement label TBD">
    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>operator</tdml:error>  
      <tdml:error>+</tdml:error>    
      <tdml:error>numeric</tdml:error>      
      <tdml:error>string</tdml:error>      
    </tdml:errors>
  </tdml:parserTestCase>
  
  <tdml:defineSchema name="elementFormWithWhitespace">

    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited"
      lengthUnits="bytes" encoding="US-ASCII" initiator=""
      terminator="" occursCountKind="parsed" ignoreCase="no"
      textNumberRep="standard" representation="text">

      <dfdl:property name="separator"> { fn:concat("1", "2") } </dfdl:property>

    </dfdl:format>

    <xs:element name="e1" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="e2" type="xs:int" maxOccurs="unbounded"
            dfdl:lengthKind="delimited"  />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <!--
     Test Name: element_long_form_whitespace
        Schema: elementFormWithWhitespace
          Root: e1
       Purpose: This test demonstrates that whitespace in an element form before or after braces is legal.
-->

  <tdml:parserTestCase name="element_long_form_whitespace" root="e1"
    model="elementFormWithWhitespace" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>3512446</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:e2>35</ex:e2>
          <ex:e2>446</ex:e2>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="unknown-prefix">
    <dfdl:format ref="ex:daffodilTest1" />
    <xs:element name="theElementName" type="xs:int"
      dfdl:inputValueCalc="{ theUnknownPrefix:x }" />
  </tdml:defineSchema>

  <tdml:parserTestCase name="expression_unknown_prefix"
    root="theElementName" model="unknown-prefix"
    description="get compilation time error due to unknown prefix - DFDL-2-001R requirement makes a reference to this test -Assigned to requirement DFDL-23-011R">
    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition</tdml:error>
      <tdml:error>theUnknownPrefix</tdml:error>
      <tdml:error>theElementName</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--- begin ssustrich's test -->

  <tdml:defineSchema name="expresion_path_error">
    <dfdl:format ref="ex:daffodilTest1" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="reps" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="scale" type="xs:int"
            dfdl:representation="binary" dfdl:lengthKind="implicit" />
          <xs:element name="s1" type="xs:string"
            dfdl:lengthKind="explicit" dfdl:length="{1}"
            dfdl:occursCount="{ ../../ex:reps * /ex:e1/ex:scale}"
            dfdl:occursCountKind="expression" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="expresion_bad_path_to_element"
    root="e1" model="expresion_path_error"
    description="very simple occursCountKind expression - DFDL-23-011R">

    <tdml:document>
      <!-- two binary integers get multiplied 2x2=4 -->
      <tdml:documentPart type="byte">00000002 00000002
			</tdml:documentPart>
      <!-- followed by that many characters, each is an element of the array -->
      <tdml:documentPart type="text">abcd</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error />
    </tdml:errors>

    <!-- <tdml:infoset> <tdml:dfdlInfoset> <ex:e1> <ex:reps>2</ex:reps> <ex:scale>2</ex:scale>
      <ex:s1>a</ex:s1> <ex:s1>b</ex:s1> <ex:s1>c</ex:s1> <ex:s1>d</ex:s1>
      </ex:e1>
      </tdml:dfdlInfoset> </tdml:infoset> -->
  </tdml:parserTestCase>


  <!--- end ssustrich's test -->

  <tdml:defineSchema name="v">
    <dfdl:format ref="ex:daffodilTest1" />
    <xs:element name="e">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="cnt" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="v" type="xs:int"
                  dfdl:inputValueCalc="{ dfdl:occursIndex() }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="f">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="cnt1" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator=";" />
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt1) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="v" type="xs:int"
                  dfdl:inputValueCalc="{ dfdl:occursIndex() }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="cnt2" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt2) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="v" type="xs:int"
                  dfdl:inputValueCalc="{ dfdl:occursIndex() }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="g">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="cnt1" type="xs:int"
            dfdl:lengthKind="delimited" dfdl:terminator=";" />
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt1) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="v" type="xs:int"
                  dfdl:inputValueCalc="{ dfdl:occursIndex() }" />
                <xs:element name="cnt2" type="xs:int"
                  dfdl:lengthKind="delimited" dfdl:terminator=";" />
                <xs:element name="b" minOccurs="0" maxOccurs="unbounded"
                  dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt2) }">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:element name="w" type="xs:int"
                        dfdl:inputValueCalc="{ dfdl:occursIndex() }" />
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>

        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="h">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="cnt" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="v" type="xs:int"
                  dfdl:inputValueCalc="{ if (dfdl:occursIndex() mod 2 eq 1) then 0 else dfdl:occursIndex() }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="noFunc">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="err" type="xs:int"
            dfdl:inputValueCalc="{ dfdl:notAFunction(1, 2, 3) }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="constantFunction">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="six" type="xs:int"
            dfdl:length="{ fn:string-length('123456') }"
            dfdl:lengthKind="explicit" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="nonFunctionIsDetected"
    root="noFunc" model="v"
    description="Schema definition error in general syntax of DFDL expression - DFDL-23-063R">

    <tdml:document />

    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>notAFunction</tdml:error>
      <tdml:error>unsupported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="constantFunction1"
    root="constantFunction" model="v"
    description="Use of fn:string-length() - DFDL-23-101R">

    <tdml:document>999999</tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <constantFunction>
          <six>999999</six>
        </constantFunction>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <tdml:parserTestCase name="dfdlPosition1" root="e"
    model="v" description="Use of dfdl:occursIndex() - DFDL-23-134R">

    <tdml:document>1</tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <cnt>1</cnt>
          <a>
            <v>1</v>
          </a>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="dfdlPosition2" root="e"
    model="v" description="Use of dfdl:occursIndex() - DFDL-23-134R">

    <tdml:document>2</tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <cnt>2</cnt>
          <a>
            <v>1</v>
          </a>
          <a>
            <v>2</v>
          </a>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="dfdlPosition3" root="f"
    model="v" description="Use of dfdl:occursIndex() - DFDL-23-134R">

    <tdml:document>2;2</tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <f>
          <cnt1>2</cnt1>
          <a>
            <v>1</v>
          </a>
          <a>
            <v>2</v>
          </a>
          <cnt2>2</cnt2>
          <a>
            <v>1</v>
          </a>
          <a>
            <v>2</v>
          </a>
        </f>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="dfdlPosition4" root="g"
    model="v" description="nested array case. Tests indexes are kept independently.">

    <tdml:document><![CDATA[2;2;2;]]></tdml:document>

    <tdml:infoset>
      <tdml:dfdlInfoset>
        <g>
          <cnt1>2</cnt1>
          <a>
            <v>1</v>
            <cnt2>2</cnt2>
            <b>
              <w>1</w>
            </b>
            <b>
              <w>2</w>
            </b>
          </a>
          <a>
            <v>2</v>
            <cnt2>2</cnt2>
            <b>
              <w>1</w>
            </b>
            <b>
              <w>2</w>
            </b>
          </a>

        </g>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="dfdlPosition5" root="h"
    model="v">

    <tdml:document>6</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <h>
          <cnt>6</cnt>
          <a>
            <v>0</v>
          </a>
          <a>
            <v>2</v>
          </a>
          <a>
            <v>0</v>
          </a>
          <a>
            <v>4</v>
          </a>
          <a>
            <v>0</v>
          </a>
          <a>
            <v>6</v>
          </a>
        </h>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="checkConstraints">
    <dfdl:format ref="ex:daffodilTest1" />
    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="cnt" type="xs:int"
            dfdl:lengthKind="delimited" />
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt) }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="v" type="xs:int"
                  dfdl:inputValueCalc="{ dfdl:checkConstraints(.) }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e2" dfdl:lengthKind="delimited">
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:assert test="{ dfdl:checkConstraints(.) }"
            message="Assertion failed for dfdl:checkConstraints(.)" />
        </xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:int">
          <xs:pattern value="[0-9]+" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>
    <xs:element name="e3" dfdl:lengthKind="delimited">
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:assert test="{ dfdl:checkConstraints(.) }"
            message="Assertion failed for dfdl:checkConstraints(.)" />
        </xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="ex:st1">
        </xs:restriction>
      </xs:simpleType>
    </xs:element>
    <xs:element name="e4" dfdl:lengthKind="delimited">
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:assert test="{ dfdl:checkConstraints(.) }"
            message="Assertion failed for dfdl:checkConstraints(.)" />
        </xs:appinfo>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="ex:st1">
          <xs:pattern value="1" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>
    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence dfdl:initiatedContent="no"
          dfdl:separatorPosition="infix" dfdl:separator=",">
          <xs:element name="a" minOccurs="0" maxOccurs="3"
            type="xs:int" dfdl:occursCountKind="parsed" dfdl:lengthKind="delimited">
            <xs:annotation>
              <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:assert test="{ dfdl:checkConstraints(.) }"
                  message="Assertion failed for dfdl:checkConstraints(.)" />
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e6">
      <xs:complexType>
        <xs:sequence dfdl:initiatedContent="no"
          dfdl:separatorPosition="infix" dfdl:separator=",">
          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
            type="xs:int" dfdl:occursCountKind="parsed" dfdl:lengthKind="delimited">
            <xs:annotation>
              <xs:appinfo source="http://www.ogf.org/dfdl/">
                <dfdl:assert test="{ dfdl:checkConstraints(.) }"
                  message="Assertion failed for dfdl:checkConstraints(.)" />
              </xs:appinfo>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    <xs:element name="e7" type="ex:ct1">
      <xs:annotation>
        <xs:appinfo source="http://www.ogf.org/dfdl/">
          <dfdl:assert test="{ dfdl:checkConstraints(.) }"
            message="Assertion failed for dfdl:checkConstraints(.)" />
        </xs:appinfo>
      </xs:annotation>
    </xs:element>
    
    <!--  This test is incorrect. An element of simple type cannot use "." 
    in any inputValueCalc, as "." means "the value of this element", so 
    we're chasing our tail here. -->
    <xs:element name="e8" type="xs:int"
      dfdl:inputValueCalc="{ dfdl:checkConstraints(.) }" />
    <xs:simpleType name="st1">
      <xs:restriction base="ex:st2">
        <xs:pattern value="[0-9]+" />
      </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="st2">
      <xs:restriction base="ex:st3">
        <xs:pattern value="[0-9]{3}" />
      </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="st3">
      <xs:restriction base="xs:string">
        <xs:pattern value="[0-9]*" />
      </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="ct1">
      <xs:sequence>
        <xs:element name="string1" type="xs:string" dfdl:lengthKind="explicit" dfdl:length="2" />
	<xs:element name="string2" type="xs:string" dfdl:lengthKind="explicit" dfdl:length="2" />
      </xs:sequence>
    </xs:complexType>
  </tdml:defineSchema>

<!-- 
     Test Name: dfdlCheckConstraints
     Schema: checkConstraints
     Purpose: This test demonstrates that checkConstraints cannot reference an inputValueCalc-ed element because the value is being computed by inputValueCalc
-->

  <tdml:parserTestCase name="dfdlCheckConstraints"
    root="e1" model="checkConstraints" description="DFDL-23-135R">
    <tdml:document>6</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Placeholder</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:parserTestCase name="checkConstraintsComplexTypeFails"
    root="e7" model="checkConstraints" description="DFDL-23-135R">
    <tdml:document>s1s2</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>checkConstraints</tdml:error>
      <tdml:error>AnyAtomic</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!-- 
     Test Name: dfdlCheckConstraints2
     Schema: checkConstraints
     Purpose: This test demonstrates that checkConstraints cannot reference an inputValueCalc-ed element because the value is being computed by inputValueCalc
-->
  <tdml:parserTestCase name="dfdlCheckConstraints2" validation="on"
    root="e8" model="checkConstraints" description="DFDL-23-135R">
    <tdml:document></tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Placeholder</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:defineSchema name="repeatFlags">
    <dfdl:format ref="ex:daffodilTest1" />
    <xs:element name="e">
      <xs:complexType>
        <xs:sequence dfdl:separator="">
          <xs:element name="present" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="s" minOccurs="0" maxOccurs="1"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:present }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="r" minOccurs="1" maxOccurs="unbounded"
                  dfdl:occursCountKind="parsed">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:annotation>
                        <xs:appinfo source="http://www.ogf.org/dfdl/">
                          <dfdl:discriminator><![CDATA[{ 
                                    if(dfdl:occursIndex() eq 1 ) then fn:true()
                                    else
                                    ../ex:r[dfdl:occursIndex() - 1]/ex:more eq 1 
                          }]]></dfdl:discriminator>
                        </xs:appinfo>
                      </xs:annotation>
                      <xs:element name="more" type="xs:int"
                        dfdl:lengthKind="explicit" dfdl:length="1" />
                      <xs:element name="c" type="xs:string"
                        dfdl:lengthKind="explicit" dfdl:length="1" />
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="extra" type="xs:string" dfdl:lengthKind="delimited"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>


  </tdml:defineSchema>

<!--
     Test Name: repeatFlags1
        Schema: repeatFlags
       Purpose: This test demonstrates the use of presence and repeat flags. In this case, the presence flag is 0,
                so there are no occurrences.
-->

  <tdml:parserTestCase name="repeatFlags1" model="repeatFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>0</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>0</present>
          <extra></extra>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatFlags2
        Schema: repeatFlags
       Purpose: This test demonstrates the use of presence and repeat flags. In this case, the presence flag is 1,
                so there is at least one occurrence. The repeat flag is 0, so there is only one occurrence, which
                in this case is the character "A".
-->

  <tdml:parserTestCase name="repeatFlags2" model="repeatFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>10A</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>1</present>
          <s>
            <r>
              <more>0</more>
              <c>A</c>
            </r>
          </s>
          <extra></extra>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatFlags3
        Schema: repeatFlags
       Purpose: This test demonstrates the use of presence and repeat flags. In this case, the presence flag is 1,
                so there is at least one occurrence. The repeat flag is 1, so there is at least one more, etc.
-->

  <tdml:parserTestCase name="repeatFlags3" model="repeatFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>11A1B1C0D</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>1</present>
          <s>
            <r>
              <more>1</more>
              <c>A</c>
            </r>
            <r>
              <more>1</more>
              <c>B</c>
            </r>
            <r>
              <more>1</more>
              <c>C</c>
            </r>
            <r>
              <more>0</more>
              <c>D</c>
            </r>
          </s>
          <extra></extra>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatFlags4
        Schema: repeatFlags
       Purpose: This test demonstrates the use of presence and repeat flags. In this case, though the fourth repeat bit
                is 0, there is more data, which should be caught by the "extra" element and not included in the primary
                element tree
-->

  <tdml:parserTestCase name="repeatFlags4" model="repeatFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>11A1B1C0D1E1F0G</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>1</present>
          <s>
            <r>
              <more>1</more>
              <c>A</c>
            </r>
            <r>
              <more>1</more>
              <c>B</c>
            </r>
            <r>
              <more>1</more>
              <c>C</c>
            </r>
            <r>
              <more>0</more>
              <c>D</c>
            </r>
          </s>
          <extra>1E1F0G</extra>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatFlags5
        Schema: repeatFlags
       Purpose: This test demonstrates the use of presence and repeat flags. In this case, the presence flag is 0, but there
                is still data in the document. This data should be consumed by the "extra" element and not included in the primary
                element tree
-->

  <tdml:parserTestCase name="repeatFlags5" model="repeatFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>01A1B1C1D1E1F0G</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>0</present>
          <extra>1A1B1C1D1E1F0G</extra>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="repeatBitFlags">
    <dfdl:format ref="ex:daffodilTest1" lengthUnits="bits"
      lengthKind="implicit" alignment="1" alignmentUnits="bits"
      representation="binary" byteOrder="bigEndian" />

    <xs:element name="bit1" type="xs:unsignedInt"
      dfdl:lengthKind="explicit" dfdl:length="1" dfdl:byteOrder="littleEndian" />

    <!-- intended for use in arrays with occursCountKind='parsed' environments -->
    <xs:group name="more">
      <xs:sequence>
        <xs:annotation>
          <xs:appinfo source="http://www.ogf.org/dfdl/">
            <dfdl:discriminator><![CDATA[{ 
                                    if (dfdl:occursIndex() eq 1 )
                                    then fn:true()
                                    else 
                                    ../ex:r[dfdl:occursIndex() - 1]/ex:more eq 1 
                          }]]></dfdl:discriminator>
          </xs:appinfo>
        </xs:annotation>
        <xs:element name="more" type="xs:unsignedInt"
          dfdl:lengthKind="explicit" dfdl:length="1" />
      </xs:sequence>
    </xs:group>

    <xs:element name="e">
      <xs:complexType>
        <xs:sequence>
          <xs:element name="present" type="xs:unsignedInt"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="s" minOccurs="0" maxOccurs="1"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:present }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="r" minOccurs="1" maxOccurs="unbounded"
                  dfdl:occursCountKind="parsed">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:group ref="ex:more" />
                      <xs:element name="c" type="xs:unsignedInt"
                        dfdl:lengthKind="explicit" dfdl:length="3" />
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="f">
      <xs:complexType>
        <xs:sequence dfdl:separator="">
          <xs:element name="present" type="xs:unsignedInt"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="s" minOccurs="0" maxOccurs="1"
            dfdl:occursCountKind="expression" dfdl:occursCount="{ ../ex:present }">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="r" minOccurs="1" maxOccurs="unbounded"
                  dfdl:occursCountKind="parsed">
                  <xs:complexType>
                    <xs:sequence>
                      <xs:group ref="ex:more" />
                      <xs:element name="c" type="xs:unsignedInt"
                        dfdl:lengthKind="explicit" dfdl:length="3" />
                    </xs:sequence>
                  </xs:complexType>
                </xs:element>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="extra" minOccurs="0" type="xs:unsignedInt" dfdl:lengthKind="explicit" dfdl:length="8"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <tdml:parserTestCase name="bit1" model="repeatBitFlags"
    root="bit1">
    <tdml:document>
      <tdml:documentPart type="bits">1</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <bit1>1</bit1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags1
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 0,
                so there are no occurrences.
-->

  <tdml:parserTestCase name="repeatBitFlags1" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>
      <tdml:documentPart type="bits">0</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>0</present>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags2
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 1,
                so there is at least one occurrence. The repeat bit is zero, so there will only be one occurrence,
                which in this case is the binary representation (in 3 bits) of 1.
-->

  <tdml:parserTestCase name="repeatBitFlags2" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>
      <tdml:documentPart type="bits">1 0 001</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>1</present>
          <s>
            <r>
              <more>0</more>
              <c>1</c>
            </r>
          </s>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags3
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 1,
                so there is at least one occurrence. The repeat bit is 1, so after this occurrence there will be at least one more.
                After the first occurrence of the c element, the next repeat bit is also 1, followed by the next occurrence, etc.
                Eventually the repeat bit is 0, so the last bit of data is consumed, and parsing stops.
-->

  <tdml:parserTestCase name="repeatBitFlags3" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>
      <tdml:documentPart type="bits">1 1 001 1 010 1 011 0 100</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e>
          <present>1</present>
          <s>
            <r>
              <more>1</more>
              <c>1</c>
            </r>
            <r>
              <more>1</more>
              <c>2</c>
            </r>
            <r>
              <more>1</more>
              <c>3</c>
            </r>
            <r>
              <more>0</more>
              <c>4</c>
            </r>
          </s>
        </e>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags4
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 1,
                so there is at least one occurrence. The repeat bit is zero, so there will only be one occurrence.
                However, the document has extra data and the test runner should complain that there is leftover data.
-->

  <tdml:parserTestCase name="repeatBitFlags4" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="e">
    <tdml:document>
      <tdml:documentPart type="bits">1 0 001 0 010</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Left over data</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags5
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 1,
                so there is at least one occurrence. The repeat bit is zero, so there will only be one occurrence.
                However, the document has extra data which should be parsed as the "extra" element.
-->

  <tdml:parserTestCase name="repeatBitFlags5" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="f">
    <tdml:document>
      <tdml:documentPart type="bits">1 1 001 0 010 1 101 0 111</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <f>
          <present>1</present>
          <s>
            <r>
              <more>1</more>
              <c>1</c>
            </r>
            <r>
              <more>0</more>
              <c>2</c>
            </r>
          </s>
          <extra>215</extra>
        </f>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: repeatBitFlags6
        Schema: repeatBitFlags
       Purpose: This test demonstrates the use of presence and repeat bits. In this case, the presence bit is 1,
                so there is at least one occurrence. The repeat bit is 1, so there will be another occurrence, and so forth.
                In this case the optional extra element should not be needed.
-->

  <tdml:parserTestCase name="repeatBitFlags6" model="repeatBitFlags" description="Section 23 - Uses of Expression Language - DFDL-23-003R"
    root="f">
    <tdml:document>
      <tdml:documentPart type="bits">1 1 001 1 010 1 101 0 111</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <f>
          <present>1</present>
          <s>
            <r>
              <more>1</more>
              <c>1</c>
            </r>
            <r>
              <more>1</more>
              <c>2</c>
            </r>
            <r>
              <more>1</more>
              <c>5</c>
            </r>
            <r>
              <more>0</more>
              <c>7</c>
            </r>
          </s>
        </f>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
<!--
     Test Name: invalid_enum_1
        Schema: expressions_broken.dfdl.xsd
       Purpose: This test demonstrates that it is a schema definition error if a value other than one of the 
                enumerated values is specified for a schema property.
-->

  <tdml:parserTestCase name="invalid_enum_1" model="expressions_broken.dfdl.xsd" 
    description="Section 06 - DFDL Expressions - DFDL-6-083R" root="e1">
    <tdml:document>
      <tdml:documentPart type="text">word</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value 'hieroglyphs' is not facet-valid with respect to enumeration</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: invalid_enum_2
        Schema: expressions_broken_2.dfdl.xsd
       Purpose: This test demonstrates that it is a schema definition error if the case of the specified value 
                does not match the expected case for the enumeration.
-->

  <tdml:parserTestCase name="invalid_enum_2" model="expressions_broken_2.dfdl.xsd" 
    description="Section 06 - DFDL Expressions - DFDL-6-084R" root="e1">
    <tdml:document>
      <tdml:documentPart type="text">word</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value 'TExT' is not facet-valid with respect to enumeration</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: invalid_enum_3
        Schema: expressions_broken_3.dfdl
       Purpose: This test demonstrates that enumerations are strings unless otherwise stated. 
-->

  <tdml:parserTestCase name="invalid_enum_3" model="expressions_broken_3.dfdl.xsd" 
    description="Section 06 - DFDL Expressions - DFDL-6-085R" root="e1">
    <tdml:document>
      <tdml:documentPart type="text">word</tdml:documentPart>
    </tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Value '0' is not facet-valid with respect to enumeration</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <tdml:defineSchema name="expressionRules">

    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited"
      lengthUnits="bytes" encoding="US-ASCII" separator="" initiator=""
      terminator="" occursCountKind="parsed" ignoreCase="no"
      textNumberRep="standard" representation="text" />

    <xs:element name="e_01" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="e1" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{fn:concat(../ex:e1, '}')}" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e_02" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="e1" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{'}'}" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <dfdl:defineVariable name="v_literal_bracket" type="xs:string"
      defaultValue="{{"/>
    <dfdl:defineVariable name="v_literal_bracket2" type="xs:string"
      defaultValue="{{}"/>
 
    <xs:element name="e_03" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="e1" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ $ex:v_literal_bracket }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e_04" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator=".">
          <xs:element name="e1" type="xs:int"
            dfdl:lengthKind="explicit" dfdl:length="1" />
          <xs:element name="e2" type="xs:string"
            dfdl:lengthKind="delimited" dfdl:inputValueCalc="{ $ex:v_literal_bracket2 }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e_05" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator="{{ {{ [">
          <xs:element name="e1" type="xs:int" minOccurs="2" maxOccurs="6" dfdl:lengthKind="delimited" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>
    
    <xs:element name="e_06" dfdl:lengthKind="implicit">
      <xs:complexType>
        <xs:sequence dfdl:separator="{ {{ [">
          <xs:element name="e1" type="xs:int" minOccurs="2" maxOccurs="6" dfdl:lengthKind="delimited" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

<!--
     Test Name: expressionRules01
        Schema: expressionRules
          Root: e_01
       Purpose: This test demonstrates that { used anywhere but the first position in an expression is treated as a literal 
-->
  
  <tdml:parserTestCase name="expressionRules01" root="e_01"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-076R">

    <tdml:document>3</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_01>
          <ex:e1>3</ex:e1>
          <ex:e2>3}</ex:e2>
        </ex:e_01>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: expressionRules02
        Schema: expressionRules
          Root: e_02
       Purpose: This test demonstrates that } used anywhere but the first position in an expression is treated as a literal 
-->
  
  <tdml:parserTestCase name="expressionRules02" root="e_02"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-077R">

    <tdml:document>3</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_02>
          <ex:e1>3</ex:e1>
          <ex:e2>}</ex:e2>
        </ex:e_02>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: expressionRules03
        Schema: expressionRules
          Root: e_03
       Purpose: This test demonstrates that {{ as the first characters are treated as the literal '{' and not a DFDL expression 
-->
  
  <tdml:parserTestCase name="expressionRules03" root="e_03"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>3</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_03>
          <ex:e1>3</ex:e1>
          <ex:e2>{</ex:e2>
        </ex:e_03>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: expressionRules04
        Schema: expressionRules
          Root: e_04
       Purpose: This test demonstrates that {{ as the first characters are treated as the literal '{' and not a DFDL expression 
-->
  
  <tdml:parserTestCase name="expressionRules04" root="e_04"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>3</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e_04>
          <ex:e1>3</ex:e1>
          <ex:e2>{}</ex:e2>
        </ex:e_04>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: expressionRules05
        Schema: expressionRules
          Root: e_05
       Purpose: This test demonstrates that {{ as the first characters are treated as the literal '{' and not a DFDL expression 
  -->
  
  <tdml:parserTestCase name="expressionRules05" root="e_05"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>123{456{{789[123</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e_05>
          <e1>123</e1>
          <e1>456</e1>
          <e1>789</e1>
          <e1>123</e1>
        </e_05>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: expressionRules06
        Schema: expressionRules
          Root: e_06
       Purpose: This test demonstrates that you need to use {{ as the first characters in order for
                it to be treated as the literal '{' and not a DFDL expression 
  -->
  
  <tdml:parserTestCase name="expressionRules06" root="e_06"
    model="expressionRules" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>123{456{{789[123</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>'{ {{ [' is an unterminated expression</tdml:error>
    </tdml:errors>
    </tdml:parserTestCase>

<!--
     Test Name: regexLookahead
        Schema: newRegex 
          Root: s1
       Purpose: This test demonstrates the use of a lookahead regex to determine the length
-->
  
  <tdml:parserTestCase name="regexLookahead" root="s1"
    model="newRegex" description="Section -  - DFDL-R">

    <tdml:document>45someletters</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <s1>
          <e1>45</e1>
          <extra>someletters</extra>
        </s1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: regexLookaheadFail
        Schema: newRegex 
          Root: s1
       Purpose: This test demonstrates the case that a lookahead regex fails to find a match. 
       Note that for lengthKind='pattern' no match means zero length. Not an error.
-->
  
  <tdml:parserTestCase name="regexLookaheadFail" root="s1"
    model="newRegex" description="Section -  - DFDL-R">

    <tdml:document>45</tdml:document>
    <tdml:infoset>
    <tdml:dfdlInfoset>
    <s1><e1></e1><extra>45</extra></s1>
    </tdml:dfdlInfoset>
    </tdml:infoset>
 
  </tdml:parserTestCase>

<!--
     Test Name: regexLookaheadFail2
        Schema: newRegex 
          Root: s3
       Purpose: This test demonstrates that the pattern facet uses the XML Schema Regex library, which does not have lookaheads
-->
  
  <tdml:parserTestCase name="regexLookaheadFail2" root="s3"
    model="newRegex" description="Section -  - DFDL-R">

    <tdml:document>45someletters</tdml:document>
    <tdml:errors>
      <tdml:error>Assertion failed for dfdl:checkConstraints</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

<!--
     Test Name: regexCompatFail
        Schema: newRegex 
          Root: s4
       Purpose: This test
-->
  
  <tdml:parserTestCase name="regexCompatFail" root="s4"
    model="newRegex" description="Section -  - DFDL-R">

    <tdml:document>45someletters</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <s1>
          <e1>45</e1>
          <extra>someletters</extra>
        </s1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

<!--
     Test Name: indexLimit
        Schema: csv.dfdl.xsd
       Purpose: This test attempts to find an upper-limit to array indexing within expressions.
                It parses a large csv file, hides the actual data, and prints out the 29,030th entry.
-->

  <tdml:parserTestCase name="indexLimit" model="csv_mod_hidden.dfdl.xsd" root="file"
    description="Section 23 - Uses of Expression Language - DFDL-23-003R">
    <tdml:document>
      <tdml:documentPart type="file">csv_1.6m</tdml:documentPart>
    </tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <file>
          <header>
            <title>last</title>
            <title>first</title>
            <title>sigil</title>
          </header>
          <scoop>lannister</scoop>
        </file>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="trueFalseTypeCorrect">
  
     <dfdl:format ref="ex:daffodilTest1"/>
     
     <xs:element name="e">
     <xs:complexType>
     <xs:sequence>
     <xs:element name="x" type="xs:int" dfdl:inputValueCalc="{ 0 }"/>
     <xs:element name="f" type="xs:int" dfdl:inputValueCalc="{ if (xs:boolean(daf:trace((if (xs:int(../ex:x) eq 0) then fn:true() else fn:false()), 'predicate'))) then 2 else 3 }"/>
     </xs:sequence>
     </xs:complexType>
     </xs:element>
  </tdml:defineSchema>
  
  <tdml:parserTestCase name="trueFalseTypeCorrect" model="trueFalseTypeCorrect" root="e"
    description="Test for JIRA DFDL-433 which demonstrates the use of a corrected expression.">
    <tdml:document/>
    <tdml:infoset>
    <tdml:dfdlInfoset>
    <ex:e><ex:x>0</ex:x><ex:f>2</ex:f></ex:e>
    </tdml:dfdlInfoset>
    </tdml:infoset>
    
    </tdml:parserTestCase>

  <!--
     Test Name: whitespace_expression
        Schema: expressions-Embedded.dfdl.xsd
          Root: ws_expr
       Purpose: This test demonstrates that whitespace can be preserved with daffodil entities.
-->

  <tdml:parserTestCase name="whitespace_expression" root="ws_expr"
    model="expressions-Embedded.dfdl.xsd" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>3]
=4]
=5]
=</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:ws_expr>
          <ex:e1>3</ex:e1>
          <ex:e1>4</ex:e1>
          <ex:e1>5</ex:e1>
        </ex:ws_expr>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: whitespace_expression2
        Schema: expressions-Embedded.dfdl.xsd
          Root: ws_expr2
       Purpose: This test demonstrates that whitespace will not be preserved without daffodil entities.
  -->

  <tdml:parserTestCase name="whitespace_expression2" root="ws_expr2"
    model="expressions-Embedded.dfdl.xsd" description="Section 6 - DFDL Expressions - DFDL-06-078R">

    <tdml:document>3]4=5]</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:ws_expr2>
          <ex:e1>3</ex:e1>
          <ex:e1>4</ex:e1>
          <ex:e1>5</ex:e1>
        </ex:ws_expr2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_01
        Schema: comparisonOperators 
          Root: e1
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_01" root="e1"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>fish,bird</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e1>
          <string1>fish</string1>
          <string2>bird</string2>
          <same>false</same>
        </e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_02
        Schema: comparisonOperators 
          Root: e1
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_02" root="e1"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>fish,fish</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e1>
          <string1>fish</string1>
          <string2>fish</string2>
          <same>true</same>
        </e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_03
        Schema: comparisonOperators 
          Root: e2
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_03" root="e2"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>fish,bird</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_04
        Schema: comparisonOperators 
          Root: e2
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_04" root="e2"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>bird,bird</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_05
        Schema: comparisonOperators 
          Root: e3
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_05" root="e3"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>4,700</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e3>
          <int1>4</int1>
          <int2>700</int2>
          <oneLTtwo>true</oneLTtwo>
        </e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_06
        Schema: comparisonOperators 
          Root: e3
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_06" root="e3"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>700,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e3>
          <int1>700</int1>
          <int2>2</int2>
          <oneLTtwo>false</oneLTtwo>
        </e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_07
        Schema: comparisonOperators 
          Root: e4
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_07" root="e4"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>1,5</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_08
        Schema: comparisonOperators 
          Root: e5
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_08" root="e5"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>7.509,7.510</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e5>
          <float1>7.509</float1>
          <float2>7.51</float2>
          <oneGTtwo>false</oneGTtwo>
        </e5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_09
        Schema: comparisonOperators 
          Root: e5
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_09" root="e5"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>10,9.99</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e5>
          <float1>10.0</float1>
          <float2>9.99</float2>
          <oneGTtwo>true</oneGTtwo>
        </e5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_10
        Schema: comparisonOperators 
          Root: e6
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_10" root="e6"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>1.5,5</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_11
        Schema: comparisonOperators 
          Root: e7
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_11" root="e7"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>lemon,lemons</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e7>
          <string1>lemon</string1>
          <string2>lemons</string2>
          <notEqual>true</notEqual>
        </e7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_12
        Schema: comparisonOperators 
          Root: e7
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_12" root="e7"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>lemonade,lemonade</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e7>
          <string1>lemonade</string1>
          <string2>lemonade</string2>
          <notEqual>false</notEqual>
        </e7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_13
        Schema: comparisonOperators 
          Root: e8
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_13" root="e8"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>potayto,potahto</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_14
        Schema: comparisonOperators 
          Root: e9
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_14" root="e9"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>1,-1</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e9>
          <int1>1</int1>
          <int2>-1</int2>
          <notEqual>true</notEqual>
        </e9>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_15
        Schema: comparisonOperators 
          Root: e10
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_15" root="e10"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>5,5</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e10>
          <int1>5</int1>
          <int2>5</int2>
          <lessThanEqualTo>true</lessThanEqualTo>
        </e10>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_16
        Schema: comparisonOperators 
          Root: e10
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_16" root="e10"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>5,10</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e10>
          <int1>5</int1>
          <int2>10</int2>
          <lessThanEqualTo>true</lessThanEqualTo>
        </e10>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_17
        Schema: comparisonOperators 
          Root: e10
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_17" root="e10"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>50,10</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e10>
          <int1>50</int1>
          <int2>10</int2>
          <lessThanEqualTo>false</lessThanEqualTo>
        </e10>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_18
        Schema: comparisonOperators 
          Root: e11
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_18" root="e11"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>7,7</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_19
        Schema: comparisonOperators 
          Root: e12
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_19" root="e12"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>7,7</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e12>
          <int1>7</int1>
          <int2>7</int2>
          <greaterThanEqualTo>true</greaterThanEqualTo>
        </e12>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: comparison_operators_20
        Schema: comparisonOperators 
          Root: e12
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_20" root="e12"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>9,7</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e12>
          <int1>9</int1>
          <int2>7</int2>
          <greaterThanEqualTo>true</greaterThanEqualTo>
        </e12>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_21
        Schema: comparisonOperators 
          Root: e12
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_21" root="e12"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>9,700</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e12>
          <int1>9</int1>
          <int2>700</int2>
          <greaterThanEqualTo>false</greaterThanEqualTo>
        </e12>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_22
        Schema: comparisonOperators 
          Root: e13
       Purpose: This test demonstrates that only two-character versions of comparison operators are supported
  -->

  <tdml:parserTestCase name="comparison_operators_22" root="e13"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>7,7</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Unsupported operation</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: attribute_axis_01
        Schema: attributeAxis
          Root: e1
       Purpose: This test demonstrates that the attribute axis is not supported in path expressions
  -->

  <tdml:parserTestCase name="attribute_axis_01" root="e1"
    model="attributeAxis" description="Section 23 - DFDL Expressions - DFDL-23-066R">

    <tdml:document>NIL</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>attribute</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: attribute_axis_02
        Schema: attributeAxis
          Root: e2
       Purpose: This test demonstrates that the attribute axis is not supported in path expressions
  -->

  <tdml:parserTestCase name="attribute_axis_02" root="e2"
    model="attributeAxis" description="Section 23 - DFDL Expressions - DFDL-23-066R">

    <tdml:document>NIL</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>attribute</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: attribute_axis_03
        Schema: attributeAxis
          Root: e3
       Purpose: This test demonstrates that the attribute axis is not supported in path expressions
  -->

  <tdml:parserTestCase name="attribute_axis_03" root="e3"
    model="attributeAxis" description="Section 23 - DFDL Expressions - DFDL-23-066R">

    <tdml:document>NIL</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>attribute</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: asterisk_01
        Schema: asterisk
          Root: e1
       Purpose: This test demonstrates that in an expression, the asterisk cannot be used to denote all children 
  -->

  <tdml:parserTestCase name="asterisk_01" root="e1"
    model="asterisk" description="Section 23 - DFDL Expressions - DFDL-23-068R2">

    <tdml:document>one,two,three</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>unsupported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: asterisk_02
        Schema: asterisk
          Root: e2
       Purpose: This test demonstrates that in an expression, the asterisk cannot be used to denote all children 
  -->

  <tdml:parserTestCase name="asterisk_02" root="e2"
    model="asterisk" description="Section 23 - DFDL Expressions - DFDL-23-068R2">

    <tdml:document>one,two,three</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>unsupported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <tdml:defineSchema name="predicates">

    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="index" type="xs:int" />
          <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10"/>
          <xs:element name="p" type="xs:string" dfdl:inputValueCalc="{ /ex:e1/ex:item[ /ex:e1/ex:index ] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence dfdl:separator=";">
          <xs:element name="item" minOccurs="0" maxOccurs="10" >
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="a" type="xs:string"/>
                <xs:element name="b" type="xs:string"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="p" type="xs:string" dfdl:inputValueCalc="{ /ex:e2/ex:item[ b='four' ]/ex:a }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator=";">
          <xs:element name="item" minOccurs="0" maxOccurs="10" >
            <xs:complexType>
              <xs:sequence dfdl:separator=",">
                <xs:element name="a" type="xs:int"/>
                <xs:element name="b" type="xs:int"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="p" type="xs:int" dfdl:inputValueCalc="{ /ex:e3/ex:item[ a>5 ]/ex:a }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="item" type="xs:string" minOccurs="0" maxOccurs="10"/>
          <xs:element name="p" type="xs:string" dfdl:inputValueCalc="{ /ex:e4/ex:item[ 6-5 ] }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
  </tdml:defineSchema>

  <!--
     Test Name: predicate_01
        Schema: predicates
          Root: e1
       Purpose: This test demonstrates that DPath can use predicates to index arrays. 
  -->

  <tdml:parserTestCase name="predicate_01" root="e1"
    model="predicates" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>2,one,two,three</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:index>2</ex:index>
          <ex:item>one</ex:item>
          <ex:item>two</ex:item>
          <ex:item>three</ex:item>
          <ex:p>two</ex:p>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: predicate_02
        Schema: predicates
          Root: e2
       Purpose: This test demonstrates that DPath can only use integer expressions as predicates.
  -->

  <tdml:parserTestCase name="predicate_02" root="e2"
    model="predicates" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>one,two;three,four;five,six</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e4>
          <ex:item>one</ex:item>
          <ex:item>two</ex:item>
          <ex:item>three</ex:item>
          <ex:p>one</ex:p>
        </ex:e4>
      </tdml:dfdlInfoset>
    </tdml:infoset>

  </tdml:parserTestCase>

  <!--
     Test Name: predicate_03
        Schema: predicates
          Root: e3
       Purpose: This test demonstrates that DPath can only use integer expressions as predicates. 
  -->

  <tdml:parserTestCase name="predicate_03" root="e3"
    model="predicates" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>1,6;14,3;2,9</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Placeholder</tdml:error>
    </tdml:errors>

  </tdml:parserTestCase>

  <!--
     Test Name: predicate_04
        Schema: predicates
          Root: e4
       Purpose: This test demonstrates that DPath can use predicates to index arrays.
  -->

  <tdml:parserTestCase name="predicate_04" root="e4"
    model="predicates" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>one,two,three</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e4>
          <ex:item>one</ex:item>
          <ex:item>two</ex:item>
          <ex:item>three</ex:item>
          <ex:p>one</ex:p>
        </ex:e4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_23
        Schema: comparisonOperators 
          Root: e14
       Purpose: This test demonstrates that lexicographic collation order is used for string comparison 
  -->

  <tdml:parserTestCase name="comparison_operators_23" root="e14"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>one2,one12</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e14>
          <string1>one2</string1>
          <string2>one12</string2>
          <oneGTtwo>true</oneGTtwo>
        </e14>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_24
        Schema: comparisonOperators 
          Root: e14
       Purpose: This test demonstrates that lexicographic collation order is used for string comparison 
  -->

  <tdml:parserTestCase name="comparison_operators_24" root="e14"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>125,4</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e14>
          <string1>125</string1>
          <string2>4</string2>
          <oneGTtwo>false</oneGTtwo>
        </e14>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_25
        Schema: comparisonOperators 
          Root: e15
       Purpose: This test demonstrates that lexicographic collation order is used for string comparison 
  -->

  <tdml:parserTestCase name="comparison_operators_25" root="e15"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>100,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e15>
          <string1>100</string1>
          <string2>2</string2>
          <oneLTtwo>true</oneLTtwo>
        </e15>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: comparison_operators_26
        Schema: comparisonOperators 
          Root: e15
       Purpose: This test demonstrates that lexicographic collation order is used for string comparison 
  -->

  <tdml:parserTestCase name="comparison_operators_26" root="e15"
    model="comparisonOperators" description="Section 23 - DFDL Expressions - DFDL-23-068R1">

    <tdml:document>100000,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e15>
          <string1>100000</string1>
          <string2>2</string2>
          <oneLTtwo>true</oneLTtwo>
        </e15>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="and_or_schema">

    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="and" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 and fn:round(../ex:float1) eq 1.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="and" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 and fn:round(../ex:float1) eq 1.0 and fn:round(../ex:float2) eq 2.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="or" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 or fn:round(../ex:float1) eq 1.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="or" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 or fn:round(../ex:float1) eq 1.0 or fn:round(../ex:float2) eq 2.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="andor" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 and fn:round(../ex:float1) eq 1.0 or fn:round(../ex:float2) eq 2.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e6">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="andor" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 or fn:round(../ex:float1) eq 1.0 and fn:round(../ex:float2) eq 2.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e7">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="andor" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq 'abc' or ../ex:string1 eq ../ex:string2 or fn:round(../ex:float1) eq 1.0 and fn:round(../ex:float2) eq 2.0 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e8">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="andor" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 or fn:round(../ex:float1) eq 1.0 and fn:round(../ex:float2) eq 2.0 or ../ex:string1 eq 'abc' }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e9">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="string1" type="xs:string"/>
          <xs:element name="string2" type="xs:string"/>
          <xs:element name="float1" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="float2" type="xs:float" dfdl:lengthKind="delimited" dfdl:textStandardNaNRep="NaN" />
          <xs:element name="andor" type="xs:boolean" dfdl:inputValueCalc="{ ../ex:string1 eq ../ex:string2 and fn:round(../ex:float1) eq 1.0 or fn:round(../ex:float2) eq 2.0 and ../ex:string1 eq 'abc' }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

  </tdml:defineSchema>

  <!--
     Test Name: sequential_and_01
        Schema: and_or_schema
          Root: e1
       Purpose: This test demonstrates that the and operator is evaluated sequentially, so it stops at the first false.
  -->

  <tdml:parserTestCase name="sequential_and_01" root="e1"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,NaN</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>NaN</ex:float1>
          <ex:and>false</ex:and>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_02
        Schema: and_or_schema
          Root: e2
       Purpose: This test demonstrates that the and operator is evaluated sequentially, so it stops at the first false.
  -->

  <tdml:parserTestCase name="sequential_and_02" root="e2"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,3.5,NaN</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e2>
          <ex:string1>abc</ex:string1>
          <ex:string2>abc</ex:string2>
          <ex:float1>3.5</ex:float1>
          <ex:float2>NaN</ex:float2>
          <ex:and>false</ex:and>
        </ex:e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_03
        Schema: and_or_schema
          Root: e2
       Purpose: This test demonstrates that the and operator is evaluated sequentially, so it stops at the first false.
          This test gets a Parse Error because the first expression evaluated to true so it continues to parse.
  -->

  <tdml:parserTestCase name="sequential_and_03" root="e2"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,NaN,2</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_04
        Schema: and_or_schema
          Root: e2
       Purpose: This test demonstrates that the and operator is evaluated sequentially, so it stops at the first false.
          This test does not have a false so it continues parsing until the parse error.
  -->

  <tdml:parserTestCase name="sequential_and_04" root="e2"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,1,NaN</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_05
        Schema: and_or_schema
          Root: e2
       Purpose: This test demonstrates that multiple and operators can be used in an expression.
  -->

  <tdml:parserTestCase name="sequential_and_05" root="e2"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,1,7.5</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e2>
          <ex:string1>abc</ex:string1>
          <ex:string2>abc</ex:string2>
          <ex:float1>1.0</ex:float1>
          <ex:float2>7.5</ex:float2>
          <ex:and>false</ex:and>
        </ex:e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_or_01
        Schema: and_or_schema
          Root: e3
       Purpose: This test demonstrates that the or operator is evaluated sequentially, so it stops at the first true.
  -->

  <tdml:parserTestCase name="sequential_or_01" root="e3"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,NaN</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e3>
          <ex:string1>abc</ex:string1>
          <ex:string2>abc</ex:string2>
          <ex:float1>NaN</ex:float1>
          <ex:or>true</ex:or>
        </ex:e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_or_02
        Schema: and_or_schema
          Root: e4
       Purpose: This test demonstrates that the or operator is evaluated sequentially, so it stops at the first true.
  -->

  <tdml:parserTestCase name="sequential_or_02" root="e4"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,1.2,NaN</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e4>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>1.2</ex:float1>
          <ex:float2>NaN</ex:float2>
          <ex:or>true</ex:or>
        </ex:e4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_or_03
        Schema: and_or_schema
          Root: e4
       Purpose: This test demonstrates that the or operator is evaluated sequentially, so it stops at the first true.
          This test gets a Parse Error because the first expression evaluated to false so it continues to parse.
  -->

  <tdml:parserTestCase name="sequential_or_03" root="e4"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,NaN,2</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_or_04
        Schema: and_or_schema
          Root: e4
       Purpose: This test demonstrates that the or operator is evaluated sequentially, so it stops at the first true.
          This test does not have a true so it continues parsing until the parse error.
  -->

  <tdml:parserTestCase name="sequential_or_04" root="e4"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,5.2,NaN</tdml:document>
    <tdml:errors>
      <tdml:error>Parse Error</tdml:error>
      <tdml:error>NaN</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: sequential_or_05
        Schema: and_or_schema
          Root: e4
       Purpose: This test demonstrates that multiple or operators can be used in an expression.
  -->

  <tdml:parserTestCase name="sequential_or_05" root="e4"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,4.6,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e4>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>4.6</ex:float1>
          <ex:float2>2.0</ex:float2>
          <ex:or>true</ex:or>
        </ex:e4>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_01
        Schema: and_or_schema
          Root: e5
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_01" root="e5"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,4.6,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e5>
          <ex:string1>abc</ex:string1>
          <ex:string2>abc</ex:string2>
          <ex:float1>4.6</ex:float1>
          <ex:float2>2.0</ex:float2>
          <ex:andor>true</ex:andor>
        </ex:e5>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_02
        Schema: and_or_schema
          Root: e6
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_02" root="e6"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,abc,1.0,5</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e6>
          <ex:string1>abc</ex:string1>
          <ex:string2>abc</ex:string2>
          <ex:float1>1.0</ex:float1>
          <ex:float2>5.0</ex:float2>
          <ex:andor>false</ex:andor>
        </ex:e6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_03
        Schema: and_or_schema
          Root: e6
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_03" root="e6"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,5,NaN</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e6>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>5.0</ex:float1>
          <ex:float2>NaN</ex:float2>
          <ex:andor>false</ex:andor>
        </ex:e6>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_04
        Schema: and_or_schema
          Root: e7
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_04" root="e7"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,5,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e7>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>5.0</ex:float1>
          <ex:float2>2.0</ex:float2>
          <ex:andor>true</ex:andor>
        </ex:e7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_05
        Schema: and_or_schema
          Root: e7
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_05" root="e7"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,5,7</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e7>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>5.0</ex:float1>
          <ex:float2>7.0</ex:float2>
          <ex:andor>false</ex:andor>
        </ex:e7>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_06
        Schema: and_or_schema
          Root: e8
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_06" root="e8"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc,def,5,7</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e8>
          <ex:string1>abc</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>5.0</ex:float1>
          <ex:float2>7.0</ex:float2>
          <ex:andor>true</ex:andor>
        </ex:e8>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: sequential_and_or_07
        Schema: and_or_schema
          Root: e9
       Purpose: This test demonstrates that and/or operators can be used in the same expression.
  -->

  <tdml:parserTestCase name="sequential_and_or_07" root="e9"
    model="and_or_schema" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>def,def,1,2</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e9>
          <ex:string1>def</ex:string1>
          <ex:string2>def</ex:string2>
          <ex:float1>1.0</ex:float1>
          <ex:float2>2.0</ex:float2>
          <ex:andor>false</ex:andor>
        </ex:e9>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: hiddenDataExpression
        Schema: hiddenElem 
          Root: e1
       Purpose: This test demonstrates that expressions operate on the augmented infoset (which includes hidden elements) 
  -->

  <tdml:parserTestCase name="hiddenDataExpression" root="e1"
    model="hiddenElem" description="Section 23 - DFDL Expressions - DFDL-23-010R">

    <tdml:document>p455w0rd</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e1>
          <hideme>p***</hideme>
        </e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
             
  </tdml:parserTestCase>
  
  <!--
     Test Name: hiddenDataExpression2
        Schema: hiddenElem 
          Root: e2
       Purpose: This test demonstrates that expressions operate on the augmented infoset (which includes hidden elements) 
  -->

  <tdml:parserTestCase name="hiddenDataExpression2" root="e2"
    model="hiddenElem" description="Section 23 - DFDL Expressions - DFDL-23-010R">

    <tdml:document>p455w0rd</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e2>
          <unhideme>p455w0rd</unhideme>
        </e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: sequenceReturned_01
        Schema: paths 
          Root: e1
       Purpose: This test demonstrates that DFDL expressions never return node-sequences 
  -->

  <tdml:parserTestCase name="sequenceReturned_01" root="e1"
    model="paths" description="Section 23 - DFDL Expressions - DFDL-23-009R1">

    <tdml:document>1,2,3,4,5</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Query-style paths not supported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: sequenceReturned_02
        Schema: paths 
          Root: e4
       Purpose: This test demonstrates that DFDL expressions never return node-sequences 
  -->

  <tdml:parserTestCase name="sequenceReturned_02" root="e4"
    model="paths" description="Section 23 - DFDL Expressions - DFDL-23-009R1">

    <tdml:document>1,1,1,1,1.2|2|2|2|2.3:3:3:3:3:3:3:3</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Query-style paths not supported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: sequenceReturned_03
        Schema: paths 
          Root: e5
       Purpose: This test demonstrates that DFDL expressions never return node-sequences 
  -->

  <tdml:parserTestCase name="sequenceReturned_03" root="e5"
    model="paths" description="Section 23 - DFDL Expressions - DFDL-23-009R1">

    <tdml:document>1+3!</tdml:document>
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>Query-style paths not supported</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>
  
  <!--
     Test Name: longPath_01
        Schema: paths 
          Root: e2
       Purpose: This test exercises DPath paths
  -->

  <tdml:parserTestCase name="longPath_01" root="e2"
    model="paths" description="Section 23 - DFDL Expressions - DFDL-23-009R">

    <tdml:document>1,2,3,4,5</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e2>
          <seq>
            <item>1</item>
            <item>2</item>
            <item>3</item>
            <item>4</item>
            <item>5</item>
          </seq>
          <items>2</items>
        </e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>
  
  <!--
     Test Name: longPath_02
        Schema: paths 
          Root: e3
       Purpose: This test exercises DPath paths
  -->

  <tdml:parserTestCase name="longPath_02" root="e3"
    model="paths" description="Section 23 - DFDL Expressions - DFDL-23-009R">

    <tdml:document>1,1,1,1,1.2|2|2|2|2.3:3:3:3:3:3:3:3</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <e3>
          <seq>
            <item>1</item>
            <item>1</item>
            <item>1</item>
            <item>1</item>
            <item>1</item>
          </seq>
          <seq2>
            <item>2</item>
            <item>2</item>
            <item>2</item>
            <item>2</item>
            <item>2</item>
          </seq2>
          <seq3>
            <item>3</item>
            <item>3</item>
            <item>3</item>
            <item>3</item>
            <item>3</item>
            <item>3</item>
            <item>3</item>
            <item>3</item>
          </seq3>
          <items>6</items>
        </e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <tdml:defineSchema name="axes">

    <dfdl:format ref="ex:daffodilTest1" lengthKind="delimited" />

    <xs:element name="e1">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="c1" type="xs:string" />
          <xs:element name="c2" type="xs:string" dfdl:inputValueCalc="{ parent::ex:e1/ex:c1 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e2">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="c1" type="xs:string" />
          <xs:element name="c2" dfdl:terminator="{ self::*/../ex:c1 }">
            <xs:complexType>
              <xs:sequence dfdl:separator="/" >
                <xs:element name="d1" type="xs:string"/>
                <xs:element name="d2" type="xs:string"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e3">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="c2" type="xs:string" dfdl:inputValueCalc="{ ../ex:c1/child::ex:d1 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e4">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1" type="xs:string" dfdl:inputValueCalc="{ 'test' }"/>
          <xs:element name="c2">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" dfdl:inputValueCalc="{ ancestor::ex:e4/ex:c1 }"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e5">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1" type="xs:string" dfdl:inputValueCalc="{ 'test' }"/>
          <xs:element name="c2">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" dfdl:inputValueCalc="{ ancestor-or-self::ex:c2/ex:d1 }"/>
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e6" type="xs:boolean" dfdl:nilKind="literalValue" nillable="true" dfdl:nilValue="NIL" dfdl:inputValueCalc="{ attribute::nil }"/>

    <xs:element name="e7">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="c2" type="xs:string" dfdl:inputValueCalc="{ /ex:e7/descendant::ex:c1/ex:d1 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e8">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="c2" type="xs:string" dfdl:inputValueCalc="{ /ex:e8/descendant-or-self::ex:c1/ex:d2 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e9">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1" type="xs:string" dfdl:inputValueCalc="{ following::ex:d1 }"/>
          <xs:element name="c2">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e10">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1" type="xs:string" dfdl:inputValueCalc="{ following-sibling::ex:c3 }"/>
          <xs:element name="c2" type="xs:string" />
          <xs:element name="c3" type="xs:string" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e11" type="xs:string" dfdl:inputValueCalc="{ namespace::* }" />

    <xs:element name="e12">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1">
            <xs:complexType>
              <xs:sequence dfdl:separator=";" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="c2" type="xs:string" dfdl:inputValueCalc="{ preceding::ex:d1 }"/>
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e13">
      <xs:complexType>
        <xs:sequence dfdl:separator="," >
          <xs:element name="c1" type="xs:string" />
          <xs:element name="c2" type="xs:string" />
          <xs:element name="c3" type="xs:string" dfdl:inputValueCalc="{ preceding-sibling::ex:c1 }" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e14">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="c1" type="xs:string" />
          <xs:element name="c2">
            <xs:complexType>
              <xs:sequence dfdl:separator="/" >
                <xs:element name="d1" type="xs:string" dfdl:inputValueCalc="{ self::ex:d1/parent::*/parent::ex:e14/child::ex:c1 }"/>
                <xs:element name="d2" type="xs:string" dfdl:inputValueCalc="{ parent::ex:d1 }" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
          <xs:element name="c3" type="xs:string" dfdl:inputValueCalc="{ parent::ex:e14/ex:c2/child::ex:d2}" />
        </xs:sequence>
      </xs:complexType>
    </xs:element>

    <xs:element name="e15">
      <xs:complexType>
        <xs:sequence dfdl:separator=",">
          <xs:element name="c1" type="xs:string" />
          <xs:element name="c2" dfdl:terminator="{ ../ex:c1 }" >
            <xs:complexType>
              <xs:sequence dfdl:separator="/" >
                <xs:element name="d1" type="xs:string" />
                <xs:element name="d2" type="xs:string" />
              </xs:sequence>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:element>
  </tdml:defineSchema>

  <!--
     Test Name: parent_axis_01
        Schema: axes
          Root: e1
       Purpose: This test demonstrates the use of "parent" as an axis.
  -->

  <tdml:parserTestCase name="parent_axis_01" root="e1"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>test</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e1>
          <ex:c1>test</ex:c1>
          <ex:c2>test</ex:c2>
        </ex:e1>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: self_axis_01
        Schema: axes
          Root: e2
       Purpose: This test demonstrates the use of "self" as an axis.
  -->

  <tdml:parserTestCase name="self_axis_01" root="e2"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>;,abc/def;</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e2>
          <ex:c1>;</ex:c1>
          <ex:c2>
            <ex:d1>abc</ex:d1>
            <ex:d2>def</ex:d2>
          </ex:c2>
        </ex:e2>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: child_axis_01
        Schema: axes
          Root: e3
       Purpose: This test demonstrates the use of "child" as an axis.
  -->

  <tdml:parserTestCase name="child_axis_01" root="e3"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc;test,</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e3>
          <ex:c1>
            <ex:d1>abc</ex:d1>
            <ex:d2>test</ex:d2>
          </ex:c1>
          <ex:c2>abc</ex:c2>
        </ex:e3>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: ancestor_axis_01
        Schema: axes
          Root: e4
       Purpose: This test demonstrates that DPath does not support the "ancestor" axis.
  -->

  <tdml:parserTestCase name="ancestor_axis_01" root="e4"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>ancestor</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: ancestor_or_self_axis_01
        Schema: axes
          Root: e5
       Purpose: This test demonstrates that DPath does not support the "ancestor-or-self" axis.
  -->

  <tdml:parserTestCase name="ancestor_or_self_axis_01" root="e5"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>ancestor-or-self</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: attribute_axis_04
        Schema: axes
          Root: e6
       Purpose: This test demonstrates that DPath does not support the "attribute" axis.
  -->

  <tdml:parserTestCase name="attribute_axis_04" root="e6"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>attribute</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: descendant_axis_01
        Schema: axes
          Root: e7
       Purpose: This test demonstrates that DPath does not support the "descendant" axis.
  -->

  <tdml:parserTestCase name="descendant_axis_01" root="e7"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>descendant</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: descendant_or_self_axis_01
        Schema: axes
          Root: e8
       Purpose: This test demonstrates that DPath does not support the "descendant-or-self" axis.
  -->

  <tdml:parserTestCase name="descendant_or_self_axis_01" root="e8"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>descendant-or-self</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: following_axis_01
        Schema: axes
          Root: e9
       Purpose: This test demonstrates that DPath does not support the "following" axis.
  -->

  <tdml:parserTestCase name="following_axis_01" root="e9"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>following</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: following_sibling_axis_01
        Schema: axes
          Root: e10
       Purpose: This test demonstrates that DPath does not support the "following-sibling" axis.
  -->

  <tdml:parserTestCase name="following_sibling_axis_01" root="e10"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>following-sibling</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: namespace_axis_01
        Schema: axes
          Root: e11
       Purpose: This test demonstrates that DPath does not support the "namespace" axis.
  -->

  <tdml:parserTestCase name="namespace_axis_01" root="e11"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>namespace</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: preceding_axis_01
        Schema: axes
          Root: e12
       Purpose: This test demonstrates that DPath does not support the "preceding" axis.
  -->

  <tdml:parserTestCase name="preceding_axis_01" root="e12"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>preceding</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: preceding_sibling_axis_01
        Schema: axes
          Root: e13
       Purpose: This test demonstrates that DPath does not support the "preceding-sibling" axis.
  -->

  <tdml:parserTestCase name="preceding_sibling_axis_01" root="e13"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document />
    <tdml:errors>
      <tdml:error>Schema Definition Error</tdml:error>
      <tdml:error>preceding-sibling</tdml:error>
    </tdml:errors>
  </tdml:parserTestCase>

  <!--
     Test Name: multiple_axis_01
        Schema: axes
          Root: e14
       Purpose: This test demonstrates the use of "parent", "child", and "self" as axes.
  -->

  <tdml:parserTestCase name="multiple_axis_01" root="e14"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>abc</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e14>
          <ex:c1>abc</ex:c1>
          <ex:c2>
            <ex:d1>abc</ex:d1>
            <ex:d2>abc</ex:d2>
          </ex:c2>
          <ex:c3>abc</ex:c3>
        </ex:e14>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

  <!--
     Test Name: short_parent_axis_01
        Schema: axes
          Root: e15
       Purpose: This test demonstrates the use of "../" in a path expression as AbbrevReverseStep.
  -->

  <tdml:parserTestCase name="short_parent_axis_01" root="e15"
    model="axes" description="Section 23 - DFDL Expressions - DFDL-23-067R">

    <tdml:document>;,abc/def;</tdml:document>
    <tdml:infoset>
      <tdml:dfdlInfoset>
        <ex:e15>
          <ex:c1>;</ex:c1>
          <ex:c2>
            <ex:d1>abc</ex:d1>
            <ex:d2>def</ex:d2>
          </ex:c2>
        </ex:e15>
      </tdml:dfdlInfoset>
    </tdml:infoset>
  </tdml:parserTestCase>

</tdml:testSuite>
